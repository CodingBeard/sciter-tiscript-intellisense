// Global functions
/**
 Evaluates (interprets) input and returns its value. If input is a string then function tries to interpret it as if it contains script source code. If input is a stream object then it compiles and executes source code from it.

 Example: after execution of the following:

 var obj = eval( "({ one:1, two:2 })" );
 variable obj will contain object having two fields: one and two.

 environment is an environment object – if provided then script execution takes place in the namespace of that object.

 var env = { one:1, two:2 };
 var res = eval( "one + two", env);
 After execution of two lines above variable res will contain integer 3.
 environments is a list of objects – environments – element with index 0 is inmost environment.

 These functions available only if host application configured the engine to use them.
 * @param {String} input
 * @param {object} namespace
 * @param {String[]} namespaces
 * @returns {any}
 */
declare function eval(input: String, namespace?: Object, namespaces?: String[]): any;

/**
 a.k.a. JSON++ data parser.

 Evaluates (interprets) data literal at the input and returns its value. Input shall contain valid data literal expression otherwise parsing exception will be thrown.

 Example 1: after execution of the following:

 var obj = parseData( " { one:1, two:2 } " );
 variable obj will contain object having two fields: one and two.

 Example 2: after execution of the following:
 var v = parseData( "3.1415926" );
 variable v will contain float number 3.1415926 – parsed value of the string.

 Main difference from the eval function is that parseData will not parse and execute any function declarations or functions so it is safe to use this function when data is coming from unknown sources e.g. in AJAX like of interactions.
 * @param {String} json
 * @returns {any}
 */
declare function parseData(json: String): any;

/**
 Evaluates the input stream in serverScript mode (see below) and emits result to the output stream. Function assumes that executable script at the input is contained in <% %> brackets. Function returns result of first standalone return statement in the input stream.

 env is an environment object, it allows to pass parameters to the input script from the caller.
 * @param {String | Stream} input
 * @param {Stream} output
 * @param {Object} env
 * @returns {Object}
 */
declare function emit(input: String | Stream, output: Stream, env?: Object): any;

/**
 Loads (compiles and executes) source. Source here either string – file name or stream object. If asServerScript provided and equals to true then source is interpreted as a text with embedded script like PHP or ASP web page:

 <html> ... <% =some_script_function(); %>... </html>
 These two fragments:

 load( "c:/myscripts/test.tis" );
 and

 var s = Stream.openFile("c:/myscripts/test.tis","r"); load( s );
 are equivalent.

 Script execution takes place in the namespace of the caller of the function.
 * @param {String} source
 * @param {boolean} asServerScript
 * @returns {boolean}
 */
declare function load(source: String, asServerScript?: boolean): boolean;

/**
 Loads compiled bytecodes defined by source. Source here either string – file name or stream object.
 * @param {String} source
 * @returns {boolean}
 */
declare function loadbc(source: String): boolean;

/**
 Calls built-in compiler to compile input. Writes output bytecodes into out stream or file. Bytecodes can be loaded (executed) later by loadbc function.
 * @param {String | Stream} input
 * @param {String | Stream} output
 * @param {boolean} asServerScript
 * @returns {boolean}
 */
declare function compile(input: String | Stream, output: String | Stream, asServerScript?: boolean): boolean;


/**
 Stores the value into file filename or stream in binary form. Returns true if data was stored successfully.
 * @param {String | Stream} location
 * @param value
 * @returns {boolean}
 */
declare function store(location: String | Stream, value: any): boolean;

/**
 Restores value previously written into the file (filename) or stream by function store. Returns value or null if operation failed.
 * @param {String | Stream} location
 * @returns {any | null}
 */
declare function fetch(location: String | Stream): any | null;

/**
 Returns hash value of its argument.
 * @param {String} value
 * @returns {Integer}
 */
declare function hash(value: String): Integer;

/**
 Returns map (simple object) that has the same set of properties as the obj. Main purpose of membersOf is to be used in for( var (k,v) in membersOf(obj)) alike enumerations to scan properties of entities that have different semantic of enumeration than in instances of Object.
 * @param {Object} obj
 * @returns {Object}
 */
declare function membersOf(obj: Object): Object;

/**
 Returns a random number between 0 and maxNumber-1.
 * @param {Integer} maxNumber
 * @returns {Integer}
 */
declare function rand(maxNumber: Integer): Integer;

/**
 Parses the url string.
 * @param {String} url
 * @returns {ParsedUrl}
 */
declare function crackUrl(url: String): ParsedUrl;

/**
 Function returns symbol of the string. Internally symbol is 32bit value so symbol space is limited – it makes no sense to "symbolize" arbitrary strings.
 * @param {String} str
 * @returns {symbol}
 */
declare function symbol(str: String): symbol;

/**
 The color function constructs color value from red, green, blue and opacity components or by parsing colorStr that can be #RRGGBB or name of the CSS color.
 * @param {Integer} r
 * @param {Integer} g
 * @param {Integer} b
 * @param {Float} opacity
 * @returns {Color}
 */
declare function color(r: Integer, g: Integer, b: Integer, opacity?: Float): Color;
declare function color(colorStr: String): Color;

/**
 , these functions constructs length values of correspondent type.
 * @param {Float} v
 * @returns {Length}
 */
declare function em(v: Float): Length

declare function ex(v: Float): Length

declare function pr(v: Float): Length

declare function fx(v: Float): Length

declare function px(v: Float): Length

//declare function in(v: Float): Length

declare function cm(v: Float): Length

declare function mm(v: Float): Length

declare function pt(v: Float): Length

declare function pc(v: Float): Length

declare function dip(v: Float): Length

/**
 * flex unit value
 * @param {Float} v
 * @returns {Length}
 */
declare function flex(v: Float): Length

/**
 * constructs angle value from float number of radians
 * @param {float} v
 * @returns {Angle}
 */
declare function rad(v: Float): Angle;

/**
 * constructs angle value from number of degrees
 * @param {Float} v
 * @returns {Angle}
 */
declare function deg(v: Float): Angle;

declare const JSON: JSON;

interface JSON {
    /**
     *
     Produces canonical JSON string representation.

     If the replacer is a function (key, value)  then it gets called for each key / value pair. The function shall return JSON compatible value. If replacer  is an array , only members with key values in the array will be converted. The order in which the members are converted is the same as the order of the keys in the array. The replacer array is ignored when the value argument is also an array.

     If space is a string then all \t characters in output are replaced by that string. If it is a number then all \t characters get replaced by that number of spaces.
     * @param {Object} value
     * @param {Function | String[]} replacer
     * @param {String | Integer} space
     * @returns {String}
     */
    stringify(value: Object, replacer?: (key: String, value: any) => any | String[], space?: String | Integer): String;

    /**
     Parses JSON string.  The reviver is a function (key, value): value or function (key, value): (key,value) – allows to transform parsed into another value or key/value pair.
     * @param {String} text
     * @param {Function} reviver
     * @returns {Object}
     */
    parse(text: String, reviver?: (key: String, value: any) => any): Object;
}

declare const URL: URL;

interface URL {
    /**
     * The function parses url
     * @param {String} url
     * @returns {ParsedUrl}
     */
    parse(url: String): ParsedUrl

    /**
     * Makes url relative to baseUrl. So for:

     baseUrl: http://example.com/foo/bar.htm and
     url :  http://example.com/zar/laf.htm#location
     the function returns ../zar/laf.htm#location
     * @param {String} url
     * @param {String} baseUrl
     * @returns {String}
     */
    relative(url: String, baseUrl: String): String;

    /**
     * The function combines relative URL with base (absolute) URL.
     * @param {String} relUrl
     * @param {String} baseUrl
     * @returns {String}
     */
    absolute(relUrl: String, baseUrl: String): String;

    /**
     * The function encodes all non-url characters, space for example will be replaced by %20 , etc.
     * @param {String} str
     * @returns {String}
     */
    encode(str: String): String;

    /**
     * The function encodes all characters except the following: alphabetic, decimal digits, - _ . ! ~ * ' ( )
     * @param {String} str
     * @returns {String}
     */
    encodeParam(str: String): String;

    /**
     * The function decodes URL encoded String to its original form.
     * @param {String} str
     * @returns {String}
     */
    decode(str: String): String;

    /**
     * The function converts "file://..." string to a path to file – path string suitable for target platform.
     * @param {String} fileUrl
     * @returns {String}
     */
    toPath(fileUrl: String): String;

    /**
     * The function converts path (like C:\User\Desktop) to file URL (like file://C:/User/Desktop).
     * @param {String} path
     * @returns {String}
     */
    fromPath(path: String): String;
}

declare const Stream: StaticStream;

interface StaticStream {
    /**
     * Static method. Opens the file which name is stored in the file-name string and returns an instance of Stream object. Operations allowed to the stream returned are defined by the mode parameter-string.

     Script engine uses C/C++ runtime for opening file streams. See fopen function definition for the meaning of the mode string.
     * @param {String} fileName
     * @param mode
     * @returns {Stream | null}
     */
    openFile(fileName: String, mode?: any): Stream | null;

    /**
     * Static method. Opens the socket stream which address and port is stored in the address-port string and returns an instance of Stream object. Opens socket stream in read-write mode. Address can be either domain name or IP address. Format of address:port string is "domain:NNN" or "NNN.NNN.NNN.NNN:NNN" where N is a decimal digit. timeout is a number of seconds to wait on any operations on this socket. If execution of operation on this socket will take more than this limit then exception will be thrown by runtime system.

     numberOfAttempts is an integer – number of attempts to connect, 1 by default.

     Example: following code will print out http server response of terrainformatica.com server:
     var sock = Stream.openSocket( "www.terrainformatica.com:80" , 5 );
     if( !sock ) return;

     sock.println("GET http://www.terrainformatica.com/main.whtm HTTP/1.0");
     sock.println("User-Agent: TIScript [en]");
     sock.println("");

     while( true )
     {
         var s = sock.readln();
         if(s == undefined) break;
         stdout.println(s);
     }
     * @param {String} addressPort
     * @param {Integer} timeout
     * @param {Integer} numberOfAttempts
     * @returns {stream | null}
     */
    openSocket(addressPort: String, timeout?: Integer, numberOfAttempts?: Integer): stream | null;

    /**
     * Static method. Opens in-memory string output stream with initialSize (integer) of its buffer. Use string streams when you plan to update some string frequently or compose string from many components. String streams are also known as StringBuffer/StringBuilder in Java or .NET. To get current content of the string stream use its method toString.
     * @param {Integer} initialSize
     * @returns {Stream}
     */
    openString(initialSize?: Integer): Stream;

    /**
     *Creates so called pipe – stream used for inter-thread communications. Pipe is shared between two threads allowing two threads to communicate. See methods send(), post() and properties pending and proxy.

     The receiver is the function that has following signature: function recv(value). This function will be called when data printed by print(), println() or printf() will arrive from other side of the pipe.

     The proxy object is an object that is used as an interface with functions accessible from the alien thread (VM) sitting on other side of the pipe, See methods send() and post() below.

     Example, following fragment (from ScIDE/facades.tis) creates three pipes that are used as stdin, stdout and stderr streams in the alien VM (other ScIDE window running is separate thread).

     function receiverOut(data) { Log.print(data,false); }
     function receiverErr(data) { Log.print(data,true); }

     // callback interface
     var iface =
     {
       foo: function(v1,v2) { stdout.printf("got a call of 'foo' with %V,%V\n",v1,v2); return v1 + v2; }
     };

     view.open(f,
     Stream.openPipe( null, iface ), // call interface for the alien
     Stream.openPipe( receiverOut ), // stdout
     Stream.openPipe( receiverErr )  // stderr
     );
     * @param {String} initialValue
     * @returns {Stream}
     */
    openString(initialValue?: String): Stream;
}

declare const stdout: Stream;
declare const stderr: Stream;

interface Stream extends StaticStream {
    /** reports if this is an input stream or not. */
    readonly isInput: boolean;
    /** reports if this is an output stream or not. */
    readonly isOutput: boolean;
    /** read only, true | false */
    readonly isPipe: boolean;
    /**
     (Pipe only)

     Gets/sets proxy object used as an interface of the thread for other thread – proxy of this thread on the remote side (other thread). Each instance of the pipe can have only one proxy object on either side of the pipe so duplex inter-thread communications require two pipe streams. */
    proxy: Object | null;
    /**
     (Pipe only)

     Returns number of pending requests (not processed at the moment) issued by post() and print**() methods. */
    readonly pending: Integer;
    /** gets/sets encoding used by the stream.
     For now it supports either "none" (raw byte stream) and "utf-8" encodings. */
    encoding: String;
    /** Name of the stream – either file name or url where the data came from. Can be an empty string, e.g. for in memory streams. */
    readonly name: String;

    /**
     * Returns content of string buffer if this is a string stream or name/address of the stream if it was open as file or socket stream.
     * @returns {String}
     */
    toString(): String;

    /**
     * Closes this stream – file, socket or string stream buffer. If returnString is true then return value is a result of toString() method.
     * @param {boolean} returnString
     * @returns {String | boolean}
     */
    close(returnString?: boolean): String | boolean;

    /**
     *
     Outputs string into the stream.

     print is an equivalent of: stream << string; operation.
     * @param {String} what
     * @returns {boolean}
     */
    print(what: String): boolean;

    /**
     * Stringizer method, outputs content in brackets into the stream.
     * @param what
     * @returns {boolean}
     */
    $(what: any): boolean;

    /**
     * Outputs string appended by \r\n into the stream.
     * @param {String} what
     * @returns {boolean}
     */
    println(what: String): boolean;

    /**
     * Stringizer method, outputs content in brackets appended by \r\n into the stream.
     * @param what
     * @returns {boolean}
     */
    $n(what: any): boolean;

    /**
     *
     Prints formatted text by the rules of printf C/C++ function.

     Additional format types:

     %v and %V – these format types accept any value as an argument and produce source code representation of the value suitable for later parsing by eval() method. Thus if value is an array of values it will be printed as "[element1, element2, element3… elementN]" and object (instance of Object class) will be printed as "{key1:value1, key2:value2,…, keyN:valueN}". %v produces one line output and %V tries to produce human readable output with line feeds and tabulations.
     Use it if you need to serialize objects in AJAX/JSON fashion.

     %S – this format type converts its argument into string and outputs it with HTML escapement. So characters like ‘<‘ will be converted to "&lt;" sequences in the output.
     * @param {String} format
     * @param value
     * @returns {boolean}
     */
    printf(format: String, ...value: any[]): boolean;

    /**
     *
     Scans the stream for values according to the rules of scanf C/C++ function with wildcard (like %[a-z] ) extensions. See definition of scanf in MSDN.

     Additional format types:

     %N – scans for either float or integer number.

     Function returns array of successfully parsed values.
     * @param {String} format
     * @returns {any[]}
     */
    scanf(format: String): any[];

    /**
     *
     Outputs character into the stream. Character defined by its integer code.

     putc is an equivalent of: stream << charcode; operation.
     * @param {Integer} charCode
     * @returns {boolean}
     */
    putc(charCode: Integer): boolean;

    /**
     * Reads one character from the stream. Returns its code as integer or undefined if stream was closed or got EOF.
     * @returns {Integer | null}
     */
    getc(): Integer | null;

    /**
     * Reads sequence of characters from stream until ‘\n’ character. Returns string read without trailing ‘\r’ and ‘\n’.
     * @returns {String | null}
     */
    readln(): String | null;

    /**
     * Sends call request to the proxy interface object on other side of the pipe and waits its completion. Returns result of the remote method. Additional parameters that follow the methodName are passed to the call of remote method as normal parameters.
     * @param {Symbol} methodName
     * @param params
     * @returns {any}
     */
    send(methodName: Symbol, ...params: any[]): any;

    /**
     * Posts call request to the proxy interface object on other side of the pipe. This method does not wait for the completion of the remote method it just increases the pending counter. Additional parameters that follow the methodName are passed to the call of remote method as normal parameters.
     * @param {Symbol} methodName
     * @param params
     * @returns {null}
     */
    post(methodName: Symbol, ...params: any[]): null;
}

declare const Color: StaticColor;

interface StaticColor {
    /**
     * Static method (of the class), В constructs color value from red, green, blue and opacity components.
     * @param {Integer} r
     * @param {Integer} g
     * @param {Integer} b
     * @param {Integer | Float} opacity
     * @returns {Color}
     */
    rgba(r: Integer, g: Integer, b: Integer, opacity?: Integer | Float): Color;

    /**
     * Static method (of the class), В constructs the color from HSV values, see: http://en.wikipedia.org/wiki/HSL_color_space
     * @param {Float | angle} hue
     * @param {Float} saturation
     * @param {Float} value
     * @param {Integer | Float} opacity
     * @returns {Color}
     */
    hsv(hue: Float | angle, saturation: Float, value: Float, opacity?: Integer | Float): Color;

    /**
     * Static method (of the class), В constructs the color from HSL values, see: http://en.wikipedia.org/wiki/HSL_color_space
     * @param {Float | angle} hue
     * @param {Float} saturation
     * @param {Float} lightness
     * @param {Integer | Float} opacity
     * @returns {Color}
     */
    hsl(hue: Float | angle, saturation: Float, lightness: Float, opacity?: Integer | Float): Color;

    /**
     * Static method (of the class), В parses the string and constructs the color value. Supported formats:

     "#RGB"
     "#RRGGBB"
     "rgb(r,g,b)"
     "rgba(r,g,b,a)"
     literal color names like: "yellow", "gold", "red", etc.
     * @param {string} text
     * @returns {Color}
     */
    parse(text: string): Color;
}

interface Color extends StaticColor {
    /** 0..255, red channel. */
    readonly r: Integer;
    /** 0..255, green channel. */
    readonly g: Integer;
    /** 0..255, blue channel. */
    readonly b: Integer;
    /** 0..255, alpha channel. */
    readonly a: Integer;

    /**
     * Returns new color by setting hue component of the color in HSL color space, hue is either angle or float, degrees 0 .. 360.
     * @param {Angle} hue
     * @returns {Color}
     */
    hue(hue: Angle): Color;

    /**
     * Returns new color by incrementing/decrementing hue component of the color in HSL color space by the given angle
     * @param {Angle} hue
     * @returns {Color}
     */
    rotate(hue: Angle): Color;

    /**
     * Returns new color by setting lightness component of the color in HSL color space.
     * @param {Float} lightness
     * @returns {Color}
     */
    lightness(lightness: Float): Color;

    /**
     * Returns new color by incrementing lightness component of the color in HSL color space.
     * @param {Float} dl
     * @returns {Color}
     */
    lighten(dl: Float): Color;

    /**
     * Returns new color by decrementing lightness component of the color in HSL color space.
     * @param {Float} dl
     * @returns {Color}
     */
    darken(dl: Float): Color;

    /**
     * Returns new color by setting saturation component of the color in HSL color space.
     * @param {Float} saturation
     * @returns {Color}
     */
    saturation(saturation: Float): Color;

    /**
     * Returns new color by incrementing saturation component of the color in HSL color space.
     * @param {Float} ds
     * @returns {Color}
     */
    saturate(ds: Float): Color;

    /**
     * Returns new color by decrementing saturation component of the color in HSL color space.
     * @param {Float} ds
     * @returns {Color}
     */
    desaturate(ds: Float): Color;

    /**
     * Returns new color by changing alpha component of the color in RGBA color space.
     * @param {Float} opacity
     * @returns {Color}
     */
    opacity(opacity: Float): Color;

    /**
     * Returns new color by incrementing/decrementing alpha component of the color in RGBA color space.
     * @param {Float} delta
     * @returns {Color}
     */
    opacify(delta: Float): Color;

    /**
     * Returns new color by mixing the color with its pure grayscale version.
     * @param {Float} ratio
     * @returns {Color}
     */
    grayscale(ratio: Float): Color;

    /**
     * Returns string representation of the color value according to the format provided by the symbol defining one of formats:

     #RGB – outputs color as "#RRGGBB";
     #rgb – outputs color as "rgb(r,g,b)" string;
     #rgba – as "rgba(r,g,b,a)" string.
     * @param {Symbol} symbol
     * @returns {String}
     */
    toString(symbol?: Symbol): String;

    /**
     * Converts the color to 32bit integer.
     * @returns {Integer}
     */
    toInteger(): Integer;

    /**
     * Returns three values – H,S, and V color components .
     * @returns {MultipleReturnValue}
     */
    toHSV(): MultipleReturnValue; //float,float,float

    /**
     * Returns three values – H,S, and L color components .
     * @returns {MultipleReturnValue}
     */
    toHSL(): MultipleReturnValue; //float,float,float

    /**
     * Computes the average color using the formula: (to - from) * ratio + from for each color component. Transformation is made in premultiplied color space.
     * @param {Color} from
     * @param {Color} to
     * @param {float} ratio
     * @returns {Color}
     */
    morph(from: Color, to: Color, ratio: float): Color;
}

declare const Length: StaticLength;

interface StaticLength {
    /**
     * static method (method of the class), parses text for the length value. In case of parsing failure returns value defined by defval.
     * @param {String} text
     * @param {Length} defaultValue
     * @returns {Length}
     */
    parse(text: String, defaultValue?: Length): Length;
}

interface Length extends StaticLength {
    /**
     * static function, constructs length of correspondent value and the unit symbol (above).
     * @param {Integer | Float} v
     * @param {Symbol} units
     * @returns {length}
     */
    make(v: Integer | Float, units: Symbol): Length;

    /**
     * Returns string representation of the value, e.g. "12.5pt", "1px", etc.
     * @returns {String}
     */
    toString(): String;

    /**
     * Converts the length to integer.
     * @returns {Integer}
     */
    toInteger(): Integer;

    /**
     * Converts the length to float. If unit is provided and its value is one the units above then the result be float representation in that units. If conversion is not possible the defvalue is returned (or 0.0 if it is omitted)
     * @param {Symbol} unit
     * @param {Float} defaultValue
     * @returns {float}
     */
    toFloat(unit?: Symbol, defaultValue?: Float): Float;

    /**
     * Computes the average length using the formula: (lengthTo – lengthFrom) * ratio + lengthFrom;
     * @param {Float} lengthFrom
     * @param {Float} lengthTo
     * @param ratio
     * @returns {length}
     */
    morph(lengthFrom: Float, lengthTo: Float, ratio): Length;
}

declare const Angle: StaticAngle;

interface StaticAngle {
    parse(s: String): Angle
}

interface Angle {
    /**
     * Returns number of radians.
     * @returns {Float}
     */
    toFloat(): Float

    /**
     * Returns number of degrees.
     * @returns {Integer}
     */
    toInteger(): Integer

    /**
     * Returns "NNNrad" string where NNN is a number of radians.
     * @returns {String}
     */
    toString(): String

    /**
     * Computes the average angle using the formula: (to - from) * ratio + from.
     * @param {Angle} from
     * @param {Angle} to
     * @param {Float} ratio
     * @returns {Angle}
     */
    morph(from: Angle, to: Angle, ratio: Float): Angle
}

interface Symbol {

}

interface MultipleReturnValue {

}

declare const Integer: StaticInteger;

interface StaticInteger {
    /** minimal value of the Integer type. */
    readonly MIN: Integer;
    /** maximal value of the Integer type. */
    readonly MAX: Integer;

    /**
     * Static method – returns minimum value of its arguments. E.g. Integer.min(1, 2, 3) will return 1.
     * @param {Integer} values
     * @returns {Integer}
     */
    min(...values: Integer[]): Integer;

    /**
     * Static method – returns maximum value of its arguments. E.g. Integer.max(1, 2, 3) will return 3.
     * @param {Integer} values
     * @returns {Integer}
     */
    max(...values: Integer[]): Integer;
}

interface Integer extends StaticInteger {
    /**
     * Converts this integer value to float.
     * @returns {Float}
     */
    toFloat(): Float;

    /**
     * Simply returns value of the integer.
     * @returns {Integer}
     */
    toInteger(): Integer;

    /**
     * Returns string representation of the integer using one of radix value: 10(default), 8 or 16.
     * @param {Integer} radix
     * @returns {String}
     */
    toString(radix?: Integer): String;

    /**
     * Returns string escaped by html rules. Is an alias of the toString() method here.
     * @param {Integer} radix
     * @returns {String}
     */
    toHtmlString(radix?: Integer): String;

    /**
     * Returns string escaped by url rules. Is an alias of the toString() method here.
     * @param {Integer} radix
     * @returns {String}
     */
    toUrlString(radix?: Integer): String;

    /**
     * Simply returns value of the integer itself.
     * @returns {Integer}
     */
    valueOf(): Integer;

    /**
     * This is exactly the following:

     function Integer.limit(min, max)
     {
        if( this < min ) return min;
        if( this > max ) return max;
        return this;
     }
     * @param {Integer} min
     * @param {Integer} max
     * @returns {Integer}
     */
    limit(min: Integer, max: Integer): Integer;
}

declare const Float: StaticFloat;

interface StaticFloat {
    /** minimal value of the float type. */
    readonly MIN: Float;
    /** maximal value of the float type. */
    readonly MAX: Float;

    /**
     * Static method – returns minimum value of its arguments. E.g. Float.min(1.0, 2.0, 3.0) will return 1.
     * @param {Float} values
     * @returns {Float}
     */
    min(...values: Float[]): Float;

    /**
     * Static method – returns maximum value of its arguments. E.g. Float.max(1.0, 2.0, 3.0) will return 3.0.
     * @param {Float} values
     * @returns {Float}
     */
    max(...values: Float[]): Float;
}

interface Float extends StaticFloat {

    /**
     * Simply returns value of the float.
     * @returns {Float}
     */
    toFloat(): Float;

    /**
     * Converts this float value to integer.
     * @returns {Number}
     */
    toInteger(): int;

    /**
     * Returns string representation of the float.
     * @returns {String}
     */
    toString(): String;

    /**
     * Returns string escaped by html rules. Is an alias of the toString() method here.
     * @returns {String}
     */
    toHtmlString(): String;

    /**
     * Returns string escaped by url rules. Is an alias of the toString() method here.
     * @returns {String}
     */
    toUrlString(): String;

    /**
     * Simply returns value of the float itself.
     * @returns {Float}
     */
    valueOf(): Float;

    /**
     * Returns true if this float value appears to be not a number.
     * @returns {boolean}
     */
    isNaN(): boolean;

    /**
     * Returns true if this float value is a finite number.
     * @returns {boolean}
     */
    isFinite(): boolean;

    /**
     * Computes the average value using the formula: (to - from) * ratio + from;
     * @param {Float} from
     * @param {Float} to
     * @param {Float} ratio
     * @returns {Float}
     */
    morph(from: Float, to: Float, ratio: Float): Float;
}

interface RegExp {
    /** number of matches after last exec or match methods calls. */
    length: Integer;
    /** last inspected string. */
    input: String;
    /** source code of the regular expression – string this RegExp was build from. */
    source: String;
    /** character position where the first successful match begins in a searched string, read-only. */
    readonly index: Integer;
    /** character position where the next match begins in a searched string. */
    lastIndex: Integer;

    /** read-only, returns n-th matched fragment. Index is a zero based index, integer. */
    readonly [i: number]: String | null;

    /**
     * Used for intitalization of new instance of RegExp object. regular-expresion is a string – source of the regular expression. В flags is an optional string and if provided may contain characters ‘i’ for case insensitive search and/or ‘g’ – for global search – to find all occurences of source in the input string.
     Use this constructor as: var re = new RegExp(…);
     * @param {RegExp | String} regex
     * @param {String} flags
     * @returns {RegExp}
     */
    new(regex: RegExp | String, flags?: String): RegExp;

    /**
     * Checks input string to see if a pattern exists within a string and returns true if so, and false otherwise.
     * @param input
     * @returns {true | false}
     */
    test(input): boolean;

    /**
     * Returns this RegExp object with length and list of matches set if pattern exists in input string or null otherwise.
     * @param input
     * @returns {RegExp | null}
     */
    exec(input): null | RegExp;

    /**
     * Valid after the exec() call, returns pair of integers – start and end positions of matched sub-expressions in input string
     * MultipleReturnValue: (start:integer, end:integer)
     * @param {Integer} matchIdex
     * @returns {MultipleReturnValue}
     */
    positions(matchIdex: Integer): MultipleReturnValue;
}

interface ParsedUrl {
    port: String;
    protocol: String;
    hostname: String;
    anchor: String;
    username: String;
    password: String;
    params: String;
    dir: String;
    name: String;
    ext: String;
    name_ext: String;
}

declare const Object: Object;

interface Object {
    /** Name of the class if object was created as instance of user defined class. */
    readonly className: String;
    /** Returns total number of members that this instance of object owns. */
    readonly length: Integer;

    /**
     * constructor
     *
     * @param {Object} definition
     * @returns {Object}
     */
    new(definition?: Object): Object;

    /**
     * Returns string "[object Object]"
     * @returns {String}
     */
    toString(): String;

    /**
     * Returns object itself
     * @returns {Object}
     */
    valueOf(): this;

    /**
     * Makes copy of the object and returns it. If deep === true then it does recursive, deep cloning.
     * @param {boolean} deep
     * @returns {Object}
     */
    clone(deep?: boolean): Object;

    /**
     * Extends the object by merging its properties from properties of object1, object2, etc.
     * @param {boolean} deep
     * @param objects
     */
    extend(deep?: boolean, ...objects: any[]): this;

    /**
     * Checks property by its tag for existence. If deep == true then does deep lookup – in objects itself and its chain of classes.
     * @param {String} tag
     * @param {boolean} deep
     * @returns {boolean}
     */
    exists(tag: String, deep?: boolean): boolean;

    /**
     * Removes property of the object by its tag (a.k.a. name).
     * @param {String} tag
     */
    remove(tag: String): void;

    /**
     * Calls the func with context of this equal to the object. Parameters if given passed to the function. If argv is provided then its memebers will be added to the list of parameters of the call.
     * @param {(...args: any[]) => any} func
     * @param params
     * @param {any[]} argv
     */
    call(func: (...args: any[]) => any, argv?: any[], ...params: any[]): any;

    /**
     * Reports class name and list of property name/values of the object. Intended to use for debugging purposes.
     * @param {Stream} out
     */
    show(out: Stream): void;

    /**
     * Evaluates (interprets) what with context of this equal to the object. If namespace object is given then it is used as global namespace for evaluated code.
     * @param {String | Stream} what
     * @param {Object} namespace
     * @returns {any}
     */
    eval(what: String | Stream, namespace?: Object): any;

    /**
     * Does lookup in the object for member/property by its tag. This is a direct equivalent of obj.tag construction.
     * @param tag
     * @returns {any}
     */
    propertyAt(tag: any): any;

    /**
     * Locks structure of the object – after the call any attempt to add or remove object’s property will throw an error. Values of existing properties can be changed though. Returns the object iself. If strict parameter is provided and it is exactly true then any attempt to get unknown property will throw an error.
     * @param {bool} strict
     * @returns {Object}
     */
    seal(strict: boolean): this;

    /**
     * Returns true if the object is sealed. If strict parameter is provided and is exactly true then the method returns true only if seal(true) was called for it.
     * @param {boolean} strict
     * @returns {boolean | null}
     */
    isSealed(strict: boolean): boolean | null;

    /**
     * Locks the object – makes it immutable – any attempt to add, remove and modify value of any object’s property will throw an error. Returns the object itself. If there is a strict parameter and it is exactly true then any attempt to get unknown property will throw an error.
     * @param {boolean} strict
     * @returns {this}
     */
    freeze(strict: boolean): this;

    /**
     * Returns true if the object is frozen. If strict parameter is provided and is exactly true then the method returns true only if freeze(true) was called for it.
     * @param {boolean} strict
     * @returns {boolean | null}
     */
    isFrozen(strict: boolean): boolean | null;

    /**
     Attaches observer to the object – function that is called when the object changes. The observer here is a function that has following signature:

     function observer(changeDefinition) {} where changeDefinition is tuple having following fields:

     [0] – symbol, one of #add – property added, #update – property changed or #delete – property deleted;
     [1] – object, the object that property was changed;
     [2] – symbol or string, property name;
     [3] – any, new value;
     [4] – any, old value.
     * @param {(change: any[]) => void} observer
     * @returns {null}
     */
    addObserver(observer: (change: any[]) => void): null;

    /**
     * Detaches given observer function from the object by function reference or by its name.
     * @param {(change: any[]) => void} observer
     * @param {Symbol} functionName
     * @returns {null}
     */
    removeObserver(observer?: (change: any[]) => void, functionName?: Symbol): null;

    /**
     * When given dot separated path like "one.two.three" the function returns obj/key pair – object in which "three" key is defined and that key.
     * @param {Object} namespace
     * @param {String} path
     * @returns {MultipleReturnValue} (collection: Object, key: Symbol | String)
     */
    referenceOf(namespace: Object, path: String): MultipleReturnValue;
}

declare const Array: Array;

interface Array {
    /** number of items in the array. Read/write property. */
    readonly length: Integer;

    /** element of the array at the index position, Read-write index accessor. Zero-based index. */
    [i: number]: any;

    /** first element of the array, if any. */
    first: any | null;
    /** last element of the array, if any. */
    last: any | null;

    /**
     * Constructor
     *
     * @param values
     * @returns {Array}
     */
    new(...values: any[]): Array;

    /**
     * Returns string – comma separated list of values
     * @returns {String}
     */
    toLocaleString(): String;

    /**
     * Returns String – comma separated list of values
     * @returns {String}
     */
    toString(): String;

    /**
     * Same as toString.
     * @returns {String}
     */
    valueOf(): String;

    /**
     * Returns brand new copy of the array. If deep === true then it does recursive, deep cloning.
     * @param {boolean} deep
     * @returns {Array}
     */
    clone(deep?: boolean): Array;

    /**
     * Appends array by values. Returns last inserted element.
     * @param item
     * @returns {any}
     */
    push(...item: any[]): any;

    /**
     * Removes first element of the array. Returns removed element.
     * @returns {any}
     */
    shift(): any;

    /**
     * Removes last element of the array. Returns removed element.
     * @returns {any}
     */
    pop(): any;

    /**
     * Inserts value at first array position. Returns the value.
     * @param value
     * @returns {any | null}
     */
    unshift(value: any): any | null;

    /**
     * Appends array by values. Returns the array.
     * @param item
     * @returns {Array}
     */
    concat(...item: any[]): Array

    /**
     * Returns string with all elements of the array separated by the delimeter or comma
     * @param {String} delimiter
     * @returns {String}
     */
    join(delimiter?: String): String;

    /**
     * Reverses order of elements in the array in-place. Returns the array.
     * @returns {Array}
     */
    reverse(): Array;

    /**
     * Returns new array consisting from elements of the array from start up to but not including end index.
     * @param {Integer} start
     * @param {Integer} end
     * @returns {Array | null}
     */
    slice(start: Integer, end?: Integer): Array | null;

    /**
     This method:

     Removes count number of elements at index.
     Inserts element1, element2, … at index position.
     returns removed elements as an array or empty array if count is zero.
     * @param {Integer} index
     * @param {Integer} count
     * @param items
     * @returns {Array}
     */
    splice(index: Integer, count: Integer, ...items: any[]): Array;

    /**
     * Sorts elements of the array in ascending order. If the compareFunction provided it is used for comparing elements during sort. В compareFunction shall accept two values in parameters and return -1, 0 or +1 as a result.
     * @param {(a: any, b: any) => Integer} compare
     * @returns {Array}
     */
    sort(compare: (a: any, b: any) => Integer): Array

    /**
     * Get index of the value in array. If the value is not found returns the notfound value (-1 by default).
     * @param value
     * @param {Integer} notFound
     * @returns {Integer | any}
     */
    indexOf(value: any, notFound?: any): Integer | any;

    /**
     * Get last index of the value in array. If the value is not found returns the notfound value (-1 by default).
     * @param value
     * @param notFound
     * @returns {Integer | any}
     */
    lastIndexOf(value: any, notFound?: any): Integer | any;

    /**
     * Removes element at index. Returns removed element.
     * @param {Integer} index
     * @returns {any | null}
     */
    remove(index: Integer): any | null;

    /**
     * Tries to locate element by value in the array and removes it. Returns removed element.
     * @param value
     * @returns {any | null}
     */
    removeByValue(value: any): any | null;

    /**
     This method creates a new array with the result of calling a provided callback function on every element in this array. If thisObject is provided then the callback will have it as this.

     The callback function may accept following parameters: callback(currentValue, index, array) where:

     currentValue is a value of array element at the index position;
     array is the array to what this method applied.
     The map methoddoes not mutate the array on which it is called.

     If the callback function ends with nothing (without explicit return) then the element will not go to resulting array (as when filter() method below returns false). Note: this a la filter() behavior is non standard.
     * @param {(currentValue: any, index: Integer, array: Array) => any | void} callback
     * @returns {Array}
     */
    map(callback: (currentValue: any, index: Integer, array: Array) => any | void): Array;

    /**
     This method applies the function simultaneously against two values of the array (from left-to-right) as to reduce it to a single value.

     The callback function may accept following parameters: callback(previousValue, currentValue, index, array) where:

     previousValue is either initialValue (on first run) or result of previous call of the callback function;
     currentValue is a value of array element at the index position;
     array is the array being scanned (reduced).
     The method returns result of last callback invocation. The methoddoes not mutate the array on which it is called.

     Example, this fragment calculates sum of all elements in the array:

     var total = [0, 1, 2, 3].reduce( :a, b: a + b );
     // total is 6 at this point.
     * @param {(previousValue: any, currentValue: any, index: Integer, array: Array) => any} callback
     * @param {any} initialValue
     * @returns {any}
     */
    reduce(callback: (previousValue: any, currentValue: any, index: Integer, array: Array) => any, initialValue?: any): any;

    /**
     This method calls the callbackfunction once for each element in the array, and constructs new array of all the values for whichthe callback returns true.

     The callback function may accept following parameters: callback(currentValue, index, array) where:
     currentValue is a value of array element at the index position;
     array is the array to what this method applied.
     The filter methoddoes not mutate the array on which it is called.

     Example, this code creates new array from elements of source array that are greater than 10:

     var filtered = [12, 5, 8, 130, 44].filter(:el: el > 10);
     // filtered is [12, 130, 44] here
     * @param {(currentValue: any, index: Integer, array: Array) => boolean} callback
     * @param {Object} thisObject
     * @returns {Array}
     */
    filter(callback: (currentValue: any, index: Integer, array: Array) => boolean, thisObject?: Object): Array;

    /**
     Calls predicate function for each element of the array until the predicate returns "truthy" value. Returns found element.

     The predicate is a function with the following signature:

     function (element:any [, index:integer [, arr: array ]] ) : true | false

     where:

     element – element of the array
     index – index of the element in the array
     arr – the array the find() was called with.
     If thisArg is provided then it is passed as this variable into the predicate calls.

     The function returns as found index and as the element and so it can be used as:

     var (i,v) = someArr.find(:el: el.id == "foo" ); // value and index, or
     var v = someArr.find(:el: el.id == "foo" ); // just value
     * @param {(element: any, index?: Integer, array?: Array) => boolean} predicate
     * @param {Object} thisObject
     * @returns {any}
     */
    find(predicate: (element: any, index?: Integer, array?: Array) => boolean, thisObject?: Object): any;

    /**
     Calls predicate function for each element of the array until the predicate returns "truthy" value and returns true. If there is no element in the array for which the predicate is true then the method returns false.

     The predicate is a function with the following signature:

     function (element:any [, index:integer [, arr: array ]] ) : true | false

     where:

     element – element of the array
     index – index of the element in the array
     arr – the array the find() was called with.
     If thisArg is provided then it is passed as this variable into the predicate calls.
     * @param {(element: any, index?: Integer, array?: Array) => boolean} predicate
     * @param {Object} thisObject
     * @returns {any}
     */
    some(predicate: (element: any, index?: Integer, array?: Array) => boolean, thisObject?: Object): boolean;

    /**
     Returns true if for each element in the array predicate is true. If there is any element in the array for which the predicate is false the method returns false.

     The predicate is a function with the following signature:

     function (element:any [, index:integer [, arr: array ]] ) : true | false

     where:

     element – element of the array
     index – index of the element in the array
     arr – the array the find() was called with.
     If thisArg is provided then it is passed as this variable into the predicate calls.
     * @param {(element: any, index?: Integer, array?: Array) => boolean} predicate
     * @param {Object} thisObject
     * @returns {boolean}
     */
    every(predicate: (element: any, index?: Integer, array?: Array) => boolean, thisObject?: Object): boolean;

    /**
     Attaches observer to the array – function that is called when the array changes. The observer here is a function that has following signature:

     function observer(changeDefinition) {} where changeDefinition is tuple having following fields:

     [0] – symbol, one of:#add-range (one or many elements added), #update-range (one or many elements changed) or #delete-range (elements were deleted);
     [1] – array, the object that property was changed;
     [2] – integer, range start, index of first changed elements;
     [3] – integer, range end (exclusive);
     * @param {(changeDefinition: Array) => void} observer
     * @returns {null}
     */
    addObserver(observer: (changeDefinition: any[]) => void): null;

    /**
     * Detaches given observer function from the array.
     * @param {(changeDefinition: any[]) => void} observer
     * @returns {null}
     */
    removeObserver(observer: (changeDefinition: any[]) => void): null;
}

declare const String: StaticString;

interface StaticString {
    /**
     * Static method. Returns string build from character with given integer codes.
     * @param codes
     * @returns {String}
     */
    fromCharCode(...codes: any[]): String;

    /**
     * static method, returns composed string. Note, this is a "stringizer" method.

     Example, this:

     var pt = { x:12, y:42  };
     var msg = String.$(coordinates are x:{ pt.x } y:{ pt.y });
     produces string "coordinates are x:12 y:42" Ð’ in msg variable.
     * @param any
     * @returns {String}
     */
    $(any: any): String;

    /**
     *
     Static method. Returns string formatted by the rules of sprintf C/C++ function.

     Additional format types:
     %v and %V – these format types accept any value as an argument and produce source code representation of the value suitable for later parsing by eval() method. Thus if value is an array of values it will be printed as "[element1, element2, element3… elementN]" and object (instance of Object class) will be printed as "{key1:value1, key2:value2,…, keyN:valueN}". %v produces one line output and %V tries to produce human readable output with line feeds and tabulations.
     Use it if you need to serialize objects in AJAX/JSON fashion.
     %S – this format type converts its argument into string and outputs it with HTML escapement. So characters like ‘<‘ will be converted to "&lt;" sequences in the output.
     * @param format
     * @param values
     * @returns {String}
     */
    printf(format, ...values: any[]): String;
}

interface String extends StaticString {
    /** number of characters in the string. Read-only property. */
    readonly length: Integer;

    /** code of character at the index position, Read-write index accessor. Zero-based index. */
    [i: number]: any;

    /**
     * Creates new string of given size and fill.
     *
     * @param {Integer} len
     * @param {String} initCharCode
     * @returns {String}
     */
    new(len: Integer, initCharCode?: String): String

    /**
     * Tries to parse content of the string. If parsing failed then returns defaultValue if provided, or undefined value.
     toInteger expects string in the following format:

     [whitespace] [{+ | -}] [0 [{ x | X }]] [digits]
     * @param defaultValue
     * @param {Integer} radix
     * @returns {Integer | any | null}
     */
    toInteger(defaultValue?: any, radix?: Integer): Integer | any | null;

    /**
     *
     Tries to parse content of the string. If parsing failed then returns defaultValue if provided, or undefined value.
     toInteger expects string in the following format:

     [whitespace] [sign] [digits] [.digits] [ {d | D | e | E}[sign]digits]
     * @param defaultValue
     * @returns {Float | any | null}
     */
    toFloat(defaultValue?): Float | any | null;

    /**
     *
     Tries to parse the string into either float or integer value. This is an equivalent of:

     var n = s.toInteger( s.toFloat() );
     * @param defaultValue
     * @returns {Integer | Float | any | null}
     */
    toNumber(defaultValue?): Integer | Float | any | null;

    /**
     * Returns string itself.
     * @returns {String}
     */
    toString(): String;

    /**
     * Returns string escaped by html rules. Is an alias of the htmlEscape() method.
     * @returns {String}
     */
    toHtmlString(): String;

    /**
     * Returns string escaped by url rules. Is an alias of the urlEscape() method.
     * @returns {String}
     */
    toUrlString(): String;

    /**
     *
     start and end are integers – zero-based indexes of first and last character. Method returns string slice consisting from characters starting from start index and up to but not included end index. If end is ommited it is interpretted as equal to length.

     Negative values of start or end treated as a "right side indexes" thus expression "Script".substring(0,-1) == "Script" is valid.
     * @param {Integer} start
     * @param {Integer} end
     * @returns {String | null}
     */
    substring(start: Integer, end: Integer): String | null;

    /**
     *
     start and length are integers. Start is zero-based index of first character and length is a number of characters in the slice.

     Negative value of start interpreted as a "right side index" thus expression "Script".substr(-6) == "Script" is valid.
     * @param {Integer} start
     * @param {Integer} length
     * @returns {String | null}
     */
    substr(start: Integer, length?: Integer): String | null;

    /**
     * Equivalent of substring method.
     * @param {Integer} start
     * @param {Integer} end
     * @returns {String | null}
     */
    slice(start: Integer, end?: Integer): String | null;

    /**
     *
     This method:

     Removes count number of characters at index.
     Inserts string1, string2, … at index position.
     Returns new string – result of the operation.
     * @param {Integer} index
     * @param {Integer} count
     * @param {String} strings
     * @returns {String}
     */
    splice(index: Integer, count: Integer, ...strings: String[]): String;

    /**
     * Returns string consisting from concatenated arguments: self + string1 + string2 + string3 + … + stringN.
     * @param {String} strings
     * @returns {String}
     */
    concat(...strings: String[]): String;

    /**
     * Returns one character string. Equivalent of substr( index, 1 ). If index is out of bounds of the string then charAt returns empty string.
     * @param {Integer} index
     * @returns {String}
     */
    charAt(index: Integer): String;

    /**
     * Returns (uni)code of character at index position.
     * @param {Integer} index
     * @returns {Integer | null}
     */
    charCodeAt(index: Integer): Integer | null;

    /**
     * Searches this string for text in substring. Returns index of first occurence of substring or -1 if not found.
     * @param {String} substring
     * @param {Integer} start
     * @returns {Integer}
     */
    indexOf(substring: String, start?: Integer): Integer;

    /**
     * Searches this string for text in substring. Returns index of last occurence of substring or -1 if not found.
     * @param {String} substring
     * @param {Integer} start
     * @returns {Integer}
     */
    lastIndexOf(substring: String, start?: Integer): Integer;

    /**
     * Compares this string with what string using lexicographic character order. For example: "ABC" < "abc" is true but "ABC".lexicalCompare("abc") yelds to >= 1. If caseInsensitive is provided and true it does case insensitive comparison. By default comparison is case sensitive.
     * @param {String} what
     * @param {boolean} caseInsensitive
     * @returns {Integer}
     */
    lexicalCompare(what: String, caseInsensitive?: boolean): Integer;

    /**
     * The function returns Levenshtein distance between this string and the other. Distance is a non-negative integer, larger – less similarity between these strings.
     * @param {String} other
     * @returns {Integer}
     */
    distance(other: String): Integer;

    /**
     * Returns fragment(s) of the string which satisfy regexp.
     * @param {RegExp} regexp
     * @returns {String | String[] | null}
     */
    match(regexp: RegExp): String | String[] | null;

    /**
     * Returns RegExp object instance which satisfy string pattern.
     * @param {String} string
     * @returns {RegExp | null}
     */
    match(string: String): RegExp | null;

    /**
     *
     Returns copy of the string where all fragments satisfying regexp are replaced by replaceBy. If replaceBy is a function then this function will be called for each matching substring with parameters corresponding to the whole match and each matched sub-group.

     This example:

     var s = "212F";
     var test = /(\d+(?:\.\d*)?)F\b/g;
     function f2c(str, g1)
     {
        return ((g1.toNumber() - 32) * 5/9) + "C";
     }
     stdout.printf("%V\n", s.replace(test, f2c ));
     will convert each Fahrenheit to Celsius number in the given string (s).
     * @param {RegExp} regexp
     * @param {((whole: String) => String) | String} replaceBy
     * @returns {String}
     */
    replace(regexp: RegExp, replaceBy: ((whole: String) => String) | String): String;

    /**
     * Returns index of first occurence of string fragment satisfying regexp or -1 if not found.
     * @param {RegExp} regexp
     * @returns {Integer}
     */
    search(regexp: RegExp): Integer;

    /**
     * Splits the string separated on components by separator. Separator is either regexp object or string. Returns array of strings – substrings between separators. Limit is an integer – maximum number of elements in returned array.
     * @param separator
     * @param {Integer} limit
     * @returns {String}
     */
    split(separator, limit?: Integer): String;

    /**
     * Returns lower case copy of the string.
     * @returns {String}
     */
    toLowerCase(): String;

    /**
     * Returns upper case copy of the string.
     * @returns {String}
     */
    toUpperCase(): String;

    /**
     * Returns copy of the string with spaces removed.
     * @param {Symbol} side
     * @returns {String}
     */
    trim(side: Symbol): String;

    /**
     * Returns url-escaped copy of the string if it contains characters need to be escaped or string itself if there are no such characters. Note that non-ascii characters are converted to utf-8 sequences first and resulting codes will be escaped.
     * @returns {String}
     */
    urlEscape(): String;

    /**
     * Restores url-escaped string.
     * @returns {String}
     */
    urlUnescape(): String;

    /**
     * Returns string where each < > & " or ‘ Ð’ character replaced by &lt; &gt; &amp; &quot; or &apos; sequence.
     * @returns {String}
     */
    htmlEscape(): String;

    /**
     * Returns string where html entities replaced by correspondent character codes.
     * @returns {String}
     */
    htmlUnescape(): String;

    /**
     *
     Scans the string for values according to the rules of scanf C/C++ function with wildcard (like %[a-z] ) extensions. See definition of scanf in MSDN.

     Additional format types:

     %N – scans for either float or integer number.
     Function returns array of successfully parsed values.
     * @param {String} format
     * @returns {array}
     */
    scanf(format: String): array;
}

declare const Date: StaticDate;

interface StaticDate {
    /**
     * Static method. Tries to parse date in string. If result of parsing is successfull then returns date as number of milliseconds since midnight, January 1, 1970 UTC.
     On error returns undefiend value.
     * @param {String} string
     * @returns {Float | null}
     */
    parse(string: String): Float | null;

    /**
     * Static method. Returns number of milliseconds since midnight, January 1, 1970 UTC up to date defined by parameters
     * @param {Integer} year
     * @param {Integer} month
     * @param {Integer} day
     * @param {Integer} hour
     * @param {Integer} minute
     * @param {Integer} second
     * @param {Integer} millisecond
     * @returns {Float | null}
     * @constructor
     */
    UTC(year: Integer, month: Integer, day: Integer, hour?: Integer, minute?: Integer, second?: Integer, millisecond?: Integer): Float | null;
}

interface Date extends StaticDate {
    /** number of the day, from 1 up to number of days in current month. Read/write property. */
    day: Integer;
    /** number of the month, from 1 to 12. Read/write property. */
    month: Integer;
    /** full number of the year, e.g. 2005. Read/write property. */
    year: Integer;
    /** hour, from 0 to 23. Read/write property. */
    hour: Integer;
    /** minute, from 0 to 59. Read/write property. */
    minute: Integer;
    /** second, from 0 to 59. Read/write property. */
    second: Integer;
    /** millisecond, from 0 to 999. Read/write property. */
    millisecond: Integer;
    /** number of day of the week, from 0 to 6 where 0 is Monday. Read-only property. */
    readonly dayOfWeek: Integer;
    /** from 0 to 6 where 0 is Monday – first day of the week in current locale. Read-only class property that can be used as Date.firstDayOfWeek. */
    readonly firstDayOfWeek: Integer;
    /** number of the day, from 1 up to number of days in current month. Read/write property. */
    UTCday: Integer;
    /** number of the month, from 1 to 12. Read/write property. */
    UTCmonth: Integer;
    /**  full number of the year, e.g. 2005. Read/write property. */
    UTCyear: Integer;
    /** hour, from 0 to 23. Read/write property. */
    UTChour: Integer;
    /** minute, from 0 to 59. Read/write property. */
    UTCminute: Integer;
    /** second, from 0 to 59. Read/write property. */
    UTCsecond: Integer;
    /** millisecond, from 0 to 999. Read/write property. */
    UTCmillisecond: Integer;
    /** number of day of the week, from 0 to 6 where 0 is Monday. Read-only property. */
    readonly UTCdayOfWeek: Integer;

    /**
     * Creates new date object. If no parameters were given then initializes date fields to the current time(UTC).
     If single string parameter provided then parses date contained in the string.
     If single float parameter provided then it is treated as number of milliseconds since midnight, January 1, 1970 UTC.
     If single Date parameter provided then copy of that date object is created.
     And if year, month, day, etc. provided uses these numeric values to initialize new Date instance. Note: values are in UTC timezone.

     new Date(string) form recognizes date in RFC-822 date format ( http://www.w3.org/Protocols/rfc822/#z28 ) and ISO 8601 ( http://www.w3.org/TR/NOTE-datetime ).
     * @param {String | Float | Date} value
     * @returns {Date}
     */
    new(value?: String | Float | Date): Date;

    /**
     * Creates new date object. If no parameters were given then initializes date fields to the current time(UTC).
     If single string parameter provided then parses date contained in the string.
     If single float parameter provided then it is treated as number of milliseconds since midnight, January 1, 1970 UTC.
     If single Date parameter provided then copy of that date object is created.
     And if year, month, day, etc. provided uses these numeric values to initialize new Date instance. Note: values are in UTC timezone.

     new Date(string) form recognizes date in RFC-822 date format ( http://www.w3.org/Protocols/rfc822/#z28 ) and ISO 8601 ( http://www.w3.org/TR/NOTE-datetime ).
     * @param {Integer} year
     * @param {Integer} month
     * @param {Integer} day
     * @param {Integer} hour
     * @param {Integer} minute
     * @param {Integer} second
     * @param {Integer} millisecond
     * @returns {Date}
     */
    new(year: Integer, month: Integer, day: Integer, hour?: Integer, minute?: Integer, second?: Integer, millisecond?: Integer): Date;

    /**
     * Sattic method, constructs new date object from year, month, day, etc.

     Note: values are in UTC timezone.

     Use it as var date = Date.utc(1999,1,1);
     * @param {Integer} year
     * @param {Integer} month
     * @param {Integer} day
     * @param {Integer} hour
     * @param {Integer} minute
     * @param {Integer} second
     * @param {Integer} millisecond
     * @returns {Date}
     */
    utc(year: Integer, month: Integer, day: Integer, hour?: Integer, minute?: Integer, second?: Integer, millisecond?: Integer): Date;

    /**
     * Sattic method, constructs new date object from year, month, day, etc.

     Note: values are in local timezone .

     Use it as var date = Date.local(1999,1,1);
     * @param {Integer} year
     * @param {Integer} month
     * @param {Integer} day
     * @param {Integer} hour
     * @param {Integer} minute
     * @param {Integer} second
     * @param {Integer} millisecond
     * @returns {Date}
     */
    local(year: Integer, month: Integer, day: Integer, hour?: Integer, minute?: Integer, second?: Integer, millisecond?: Integer): Date;

    /**
     * By default it returns RFC-822 string representation of this date object.
     If format is provided then it gets interpreted by strftime rules.

     If utc is provided and is true then formatting is made without local timezone shift.
     * @param {String} format
     * @param {boolean} utc
     * @returns {String}
     */
    toString(format: String, utc?: boolean): String;

    /**
     * Returns RFC-822 string representation of this date object as UTC date/time.
     * @returns {String}
     */
    toUTCString(): String;

    /**
     * Returns ISO 8601 string representation of this date object as either local or UTC date/time.
     * @param {boolean} asUTC
     * @returns {String}
     */
    toISOString(asUTC?: boolean): String;

    /**
     * Returns string representation of the date using current system settings. Local time.
     If longFormat is equal exactly true then formats date using system long date format.
     If andTime is true then result string will also contain time.
     * @param {boolean} longFormat
     * @param {boolean} andTime
     * @returns {String}
     */
    toLocaleString(longFormat?: boolean, andTime?: boolean): String;

    /**
     * Returns stored time value in milliseconds since midnight, January 1, 1970 UTC.
     * @returns {Float}
     */
    valueOf(): Float;

    /**
     * Sets this date object fields equal to date defined by milliseconds parameter. milliseconds is a number (float) of milliseconds since midnight, January 1, 1970 UTC.
     * @param {Float} milliseconds
     * @returns {Float}
     */
    setTime(milliseconds: Float): Float;

    /**
     * Returns name of the month in current user’s locale. If longFormat is equal true returns full month name, otherwise – it’s abbreviation.
     * @param {boolean} longFormat
     * @returns {String}
     */
    monthName(longFormat: boolean): String;

    /**
     * Returns name of the day in current user’s locale. If longFormat is equal true returns full week day name, otherwise – it’s abbreviation.
     * @param {boolean} longFormat
     * @returns {String}
     */
    dayOfWeekName(longFormat: boolean): String;

    /**
     * Returns true if current clock is using daylight saving time.
     * @returns {boolean}
     */
    isDaylight(): boolean;

    /**
     * Returns shift in milliseconds of current timezone from GMT.
     * @returns {Integer}
     */
    timeZoneOffset(): Integer;

    /**
     * Returns name of current timezone.
     * @returns {String}
     */
    timeZoneName(): String;
}

interface Function {
    /** name of the function. For anonymous (lambda) functions it is undefined. */
    readonly name: String;
    /** Fully qualified name of the function, includes name of class or namespace. For anonymous (lambda) functions it is undefined. */
    readonly fullName: String;
    /** Returns total number of declared parameters. */
    readonly length: Integer;
    /** Returns number of optional parameters. */
    readonly optionals: Integer;

    /**
     * constructor, compiles the functionBody and creates function object of it. arg1… argN are names to be used by the function as formal argument names. Each must be a string that corresponds to a valid JavaScript identifier.
     * @param {String} args
     * @param {String} functionBody
     * @returns {Function}
     */
    new(args: String, functionBody: String): Function;

    /**
     * Invokes the function in context of this set to thisObj
     * @param {Object} thisObj
     * @param args
     * @returns {any}
     */
    call(thisObj: Object, ...args: any[]): any;

    /**
     * Invokes the function in context of this set to thisObj. Parameters of the function call are compsed from list of parameters p0 … pN and appended by members of argv array. Thus actual call will have following parameters list: p0, …, pN, argv[0], … argv[N].
     * @param {Object} thisObj
     * @param args
     * @returns {any}
     */
    apply(thisObj: Object, ...args: any[]): any;

    /**
     * Checks property by its tag for existence. If deep == true then does deep lookup – in function itself and its chain of classes.
     * @param {value} tag
     * @param {boolean} deep
     * @returns {boolean}
     */
    exists(tag: value, deep?: boolean): boolean;

    /**
     * Removes property of the function by its tag (a.k.a. name).
     * @param {value} tag
     */
    remove(tag: value): void;

    /**
     * Does lookup in the object for member/property by its tag. This is a direct equivalent of obj.tag construction.
     * @param {value} tag
     * @returns {any}
     */
    propertyAt(tag: value): any;

    /**
     * Locks structure of the object – after the call any attempt to add or remove object’s property will throw an error. Values of existing properties can be changed though. Returns the object iself. If strict parameter is provided and it is exactly true then any attempt to get unknown property will throw an error.
     * @param {boolean} strict
     * @returns {Object}
     */
    seal(strict: boolean): Object;

    /**
     * Returns true if the object is sealed. If strict parameter is provided and is exactly true then the method returns true only if seal(true) was called for it.
     * @param {boolean} strict
     * @returns {boolean | null}
     */
    isSealed(strict: boolean): boolean | null;

    /**
     * Locks the object – makes it immutable – any attempt to add, remove and modify value of any object’s property will throw an error. Returns the object itself. If there is a strict parameter and it is exactly true then any attempt to get unknown property will throw an error.
     * @param {boolean} strict
     * @returns {Object}
     */
    freeze(strict: boolean): Object;

    /**
     * Returns true if the object is frozen. If strict parameter is provided and is exactly true then the method returns true only if freeze(true) was called for it.
     * @param {boolean} strict
     * @returns {boolean | null}
     */
    isFrozen(strict: boolean): boolean | null;
}

declare const Math: Math;

interface Math {
    /** e – Euler’s constant, the base of natural logarithms. */
    readonly E: Float;
    /** value of natural logarithm of 2. */
    readonly LN2: Float;
    /** value of natural logarithm of 10. */
    readonly LN10: Float;
    /** value of base 2 logarithm of e constant. */
    readonly LOG2E: Float;
    /** value of base 10 logarithm of e constant. */
    readonly LOG10E: Float;
    /** Pi constant – the ratio of the circumference of a circle to its diameter. */
    readonly PI: Float;
    /** value of square root of 0.5. */
    readonly SQRT1_2: Float;
    /** value of square root of 2.0. */
    readonly SQRT2: Float;

    /**
     * Returns abs (positive) value of integer or float argument.
     * @param {Integer | Float} a
     * @returns {Integer | Float}
     */
    abs(a: Integer | Float): Integer | Float;

    /**
     * Returns value of sine of its argument.
     * @param {Integer | Float} a
     * @returns {Float}
     */
    sin(a: Integer | Float): Float;

    /**
     * Returns value of cosine of its argument.
     * @param {Integer | Float} a
     * @returns {Float}
     */
    cos(a: Integer | Float): Float;

    /**
     * Returns tangent of its argument.
     * @param {Integer | Float} a
     * @returns {Float}
     */
    tan(a: Integer | Float): Float;

    /**
     * Returns arctangent if its arguments. Calls (in C runtime) function atan() for single argument or atan2() for two arguments.
     * @param {Integer | Float} a
     * @param {Integer | Float} b
     * @returns {Float}
     */
    atan(a: Integer | Float, b?: Integer | Float): Float;

    /**
     * Returns arcsine if its argument.
     * @param {Integer | Float} a
     * @returns {Float}
     */
    asin(a: Integer | Float): Float;

    /**
     * Returns arccosine if its argument.
     * @param {Integer | Float} a
     * @returns {Float}
     */
    acos(a: Integer | Float): Float;

    /**
     * Returns the square root of the argument.
     * @param {Integer | Float} a
     * @returns {Float}
     */
    sqrt(a: Integer | Float): Float;

    /**
     * Returns the smallest integral value greater than or equal to the argument.
     * @param {Float} a
     * @returns {Float}
     */
    ceil(a: Float): Float;

    /**
     * Returns the largest integral value that is less than or equal to the argument
     * @param {Float} a
     * @returns {Float}
     */
    floor(a: Float): Float;

    /**
     * Returns the closest integral value to the argument. Math.round(3.2) -> 3.0 and Math.round(3.7) -> 4.0
     * @param {Float} a
     * @returns {Float}
     */
    round(a: Float): Float;

    /**
     * Returns the exponential value of the argument, if successful. On overflow, the function returns INF (infinite) and on underflow, exp returns 0.0. To test number on infinity use Float.isFinite(value) method.
     * @param {Integer | Float} a
     * @returns {Float}
     */
    exp(a: Integer | Float): Float;

    /**
     * The log functions return logarithms of the argument if successful. If argument is negative, these functions return an indefinite (NaN). If argument is 0, they return INF (infinite). To test number on infinity use Float.isFinite(value) method.
     * @param {Integer | Float} a
     * @returns {Float}
     */
    log(a: Integer | Float): Float;

    /**
     * The log functions return logarithms of the argument if successful. If argument is negative, these functions return an indefinite (NaN). If argument is 0, they return INF (infinite). To test number on infinity use Float.isFinite(value) method.
     * @param {Integer | Float} a
     * @returns {Float}
     */
    log2(a: Integer | Float): Float;

    /**
     * The log functions return logarithms of the argument if successful. If argument is negative, these functions return an indefinite (NaN). If argument is 0, they return INF (infinite). To test number on infinity use Float.isFinite(value) method.
     * @param {Integer | Float} a
     * @returns {Float}
     */
    log10(a: Integer | Float): Float;

    /**
     * Calculates number raised to the power of exponent: result = number^exponent
     * @param {Integer | Float} number
     * @param {Integer | Float} exponent
     * @returns {Float | Integer}
     */
    pow(number: Integer | Float, exponent: Integer | Float): Float | Integer;

    /**
     * Returns random float number in range 0.0 … 1.0
     * @returns {Float}
     */
    random(): Float;
}

declare const Bytes: StaticBytes;

interface StaticBytes {
    /**
     *
     Static method, constructs Bytes object (byte array)  from string using specified encoding.

     If encoding is not specified or is equal to "base64" then base64 encoding is used. Otherwise if encoding is one of supported encodings from IANA charset list http://www.iana.org/assignments/character-sets the function returns encoded bytes.

     E.g. var bytes = Bytes.fromString("Привет, мир!", "utf-8"); returns utf-8 encoded bytes of the string.
     * @param {String} str
     * @param {string} encoding
     * @returns {Bytes}
     */
    fromString(str: String, encoding?: string): Bytes;

    /**
     * Static method. Creates new Bytes object, loads file into it and returns that object.
     * @param {String} filename
     * @returns {Bytes}
     */
    load(filename: String): Bytes;
}

interface Bytes extends StaticBytes {
    /** element of the array at the index position, read-write index accessor. Zero-based integer index. */
    [i: number]: Integer;

    /** number of bytes in the byte vector. */
    readonly length: Integer;
    /** could be used for any purposes but sciter uses it to report mime-type (string) of the data received or sent by request() method. */
    type: String;
    /** could be used for any purposes but sciter uses it to report file name (string) of the data received or sent by request() method. */
    name: String;

    /**
     * Constructs object of type Bytes – sequence of bytes of numBytes length.
     * @param {Integer} numBytes
     */
    new(numBytes: Integer);

    /**
     *
     If encoding is not provided or is equal to "base64" then the method returns base64 representation of the byte vector. Otherwise if encoding is one of supported encondings from IANA charset list http://www.iana.org/assignments/character-sets the function returns decoded string.

     E.g. var str = bytes.toString("UTF-8"); returns a string from UTF-8 encoded bytes.
     * @param {String} encoding
     * @returns {String}
     */
    toString(encoding?: String): String;

    /**
     * returns 32 chars string that represents MD-5 digest of the byte array.
     * @returns {String}
     */
    md5(): String;

    /**
     * returns integer that is a result of CRC32 computation of given byte array.
     * @returns {Integer}
     */
    crc32(): Integer;

    /**
     * Compares two Bytes object for content equality, returns -1,0 or 1. Where 0 if these two byte vectors are equal.
     * @param {Bytes} other
     * @returns {Integer}
     */
    compare(other: Bytes): Integer;

    /**
     * Saves content of the byte vector into the file. If file exists then it will be overwritten.
     * @param {String} filename
     * @returns {boolean}
     */
    save(filename: String): boolean;

    /**
     * Creates new Bytes object – compression version of original bytes object.
     * @returns {Bytes}
     */
    compress(): Bytes;

    /**
     * Creates new Bytes object, restores previously compressed byte array. Returns null if the array was not previously compressed.
     * @returns {Bytes | null}
     */
    decompress(): Bytes | null;
}

interface Error {
    /** equals to "Error" for now. */
    readonly name: String;
    /** error message. */
    readonly message: String;
    /** stack trace of the error. */
    readonly stackTrace: String;
    /** Additional payload for the error to carry. For example in view.request() the error contains { status: ..., response: ... } object. */
    data: any;
}

declare const System: StaticSystem;

interface StaticSystem {
    /** scanFiles callback/attributes, file/dir is readonly. */
    readonly IS_READONLY: Integer;
    /** scanFiles callback/attributes, file is directory(folder). */
    readonly IS_DIR: Integer;
    /** scanFiles callback/attributes, file/dir is marked as hidden. */
    readonly IS_HIDDEN: Integer;
    /** scanFiles callback/attributes, file/dir is marked as internal for the system. */
    readonly IS_SYSTEM: Integer;
    /** true for the mosciter that is running on mobile platform, false otherwise. */
    readonly MOBILE_OS: boolean;
    /** true for the sciter running on desktop PC/platform, false otherwise. */
    readonly DESKTOP_OS: boolean;
    /** on Windows it is one of these:
     #Windows-98
     #Windows-98-SE
     #Windows-ME
     #Windows-CE – Windows CE or Windows Mobile
     #Windows-NT4
     #Windows-2000
     #Windows-2003
     #Windows-XP
     #Windows-Vista
     #Windows-7 */
    readonly OS: Symbol;
    /** one of these:
     #Windows
     #OSX
     #Linux */
    readonly PLATFORM: Symbol;
    /** platform specific end-of-line sequence, on Windows "\r\n" and on others "\n". */
    readonly EOL: String;
}

interface System extends StaticSystem {
    /** The abbreviated name of the language, ISO Standard 639 names. */
    readonly language: String;
    /** Country/region name, based on ISO Standard 3166. */
    readonly country: String;
    /** High resolution timer. Return an integer representing the time ellapsed since the engine started in milliseconds */
    readonly ticks: Integer;

    /**
     * Function calls callback function for each entry found in directory defined by the path. Path can contain wildcards like ? or *. Function returns number of entries scanned.

     If callback is ommited then function just returns number of items satisfying path condition. In this form the scan can be used for testing of some file existence as an example.

     Callback function shall accept two parameters:

     function callback( filename: string, attributes: integer ): bool

     where filename is an name of the file and attributes is an integer – OR-ed combination of IS_*** flags. Callback function shall return true if further scanning needed and false to stop enumeration.
     * @param {String} path
     * @param {(filename: String, attributes: Integer) => boolean} callback
     * @returns {Integer}
     */
    scanFiles(path: String, callback?: (filename: String, attributes: Integer) => boolean): Integer;

    /**
     * Returns home folder of the application – folder where sciter started from. If relpath is some string then it will be appended to the return value. Use this if you need to find fully qualified file name residing in sciter folder or subfolder.
     * @param {String} relpath
     * @returns {String}
     */
    home(relpath?: String): String;

    /**
     * Returns path of one of the system folders. system-folder here is one of:

     #SYSTEM
     #SYSTEM_BIN
     #PROGRAM_FILES
     #USER_APPDATA
     #COMMON_APPDATA
     #USER_DOCUMENTS
     #COMMON_DOCUMENTS
     #USER_HOME – user’s home directory
     * @param {Symbol} systemFolder
     * @param {String} relpath
     * @returns {String}
     */
    path(systemFolder: Symbol, relpath?: String): String;

    /**
     *
     Starts excutable asynchronously passing optional commnad line parameters. The method does not wait for executable to complete.

     Retuns 0 if executable has started successfully and C runtime errno variable code otherwise (EACCES, ENOTDIR, etc.).
     * @param {String} exePath
     * @param {String} arg1
     * @returns {integer}
     */
    exec(exePath: String, ...arg1: String[]): integer;
}

declare const VM: StaticVM;

interface StaticVM {
    /** global unhandled exception handler. Accepts function(err) : true | false that will receive error object. If that function returns true then the exception is considered as handled and will not be output to stderr port. */
    unhandledExceptionHandler: (error: String) => boolean;

    /**
     *
     Gets property of obj by its name.

     Equivalent of const name = "..."; var val = obj.(name);
     * @param {Object} obj
     * @param {String | Symbol} name
     * @returns {any | null}
     */
    getProperty(obj: Object, name: String | Symbol): any | null;

    /**
     *
     Sets property of obj by its name.

     Equivalent of const name = "..."; obj.(name) = val;
     * @param {Object} obj
     * @param {String | Symbol} name
     * @param val
     * @returns {any | null}
     */
    setProperty(obj: Object, name: String | Symbol, val: any): any | null;
}

declare const Storage: StaticStorage;

interface StaticStorage {
    /**
     * Static method. Opens the storage, which name is stored in the file-name string and returns an instance of Storage object.
     autocommit indicates if storage commits all associated objects into storage automatically. Default value is true.
     * @param fileName
     * @param {boolean} autocommit
     * @returns {Storage | null}
     */
    open(fileName, autocommit?: boolean): Storage | null;
}

interface Storage extends StaticStorage {
    /** root object in the storage. Read/write property. */
    root: Object;
    /** indicates if storage commits all associated objects into storage automatically. Read-only property. */
    readonly autocommit: boolean;

    /**
     * Closes underlying Storage object. Commits all data if autocommit is set to true.
     */
    close();

    /**
     * Commits all related objects into storage.
     */
    commit();

    /**
     * Creates an index of type ‘type’ and returns Index object. Index could have unique or duplicated keys depending on unique argument. Default value for unique is true. Supported types: #integer, #float, #date, #string.
     * @param {Symbol} type
     * @param {boolean} unique
     * @returns {Index | null}
     */
    createIndex(type: Symbol, unique?: boolean): Index | null;
}

interface Index {
    /** length of an index, number of objects associated represented by the index. Read-only property. */
    readonly length: Integer;
    /** direction of access of objects from the index. Write-only property. */
    asc: boolean;
    /** element of the DbIndex at the key position. Read/Write accessor by key. key has to be of the same type as the type of Index object.
     If the index was created as non unique then the return value of [] accessor is either undefined or an array – list of items under the key. */
        [key]: any;

    /**
     * Inserts val object into Index and associates it with key value. Optionally replaces it with existing object if it exists.
     * @param {Integer | String} key
     * @param val
     * @param {boolean} replace
     * @returns {boolean}
     */
    add(key: Integer | String, val: any, replace?: boolean): boolean;

    /**
     * Method removes object obj by key from the index. Method returns true on success, otherwise false.
     If Index is unique, obj is optional.
     * @param {String} key
     * @param obj
     * @returns {boolean}
     */
    remove(key: String, obj?: any): boolean;

    /**
     * Returns selection in the Index based on criteria min-key, max-key, ascent or descent order, start-inclusive, end-inclusive. Default values:

     ascent = true
     start-inclusive = true
     end-inclusive = true
     Example:
     var sel = index.select(minVal, maxVal, true);
     for( var obj in sel ) { … }
     * @param {Integer | String} minKey
     * @param {Integer | String} maxKey
     * @param {boolean} ascent
     * @param {boolean} startInclusive
     * @param {boolean} endInclusive
     * @returns {any}
     */
    select(minKey: Integer | String, maxKey: Integer | String, ascent?: boolean, startInclusive?: boolean, endInclusive?: boolean): any;

    /**
     * Removes all items from the index object.
     * @returns {undefined}
     */
    clear(): null;
}

declare const XMLScanner: StaticXMLScanner;

interface StaticXMLScanner {
    /** error in markup of input stream */
    readonly ERROR: Integer;
    /** end of stream reached */
    readonly EOF: Integer;
    /**  head of the element parsed: */
    readonly HEAD: Integer;
    /** end of head of non-empty element parsed: */
    readonly HEAD_END: Integer;
    /** end of head of empty element parsed: */
    readonly EMPTY_HEAD_END: Integer;
    /** tail of the non-empty element parsed: */
    readonly TAIL: Integer;
    /** attribute parsed: */
    readonly ATTR: Integer;
    /** text parsed. */
    readonly TEXT: Integer;
    /** cdata parsed: */
    readonly CDATA: Integer;
    /** processing instruction parsed: */
    readonly PI: Integer;
    /** doctype declaration parsed: */
    readonly DOCTYPE: Integer;
}

interface XMLScanner extends StaticXMLScanner {
    /** text of attribute value, text, cdata or pi. */
    value: String;
    /** name of the attribute. Valid if token == XMLScanner.ATTR */
    attribute: String;
    /** name of the tag. Valid if token is XMLScanner.HEAD, XMLScanner.TAIL or XMLScanner.HEAD_END. */
    tag: String;

    /**
     Returns one of constants above. Use them in fully qualified form, e.g. XMLScanner.HEAD, XMLScanner.TAIL, etc.
     * @returns {Integer}
     */
    token(): Integer;
}

// DOM

declare const Element: StaticElement;

interface StaticElement {
    /** State flags (bits) of the element, used by get/setState functions. */
    readonly STATE_LINK: Integer;
    readonly STATE_HOVER: Integer;
    readonly STATE_ACTIVE: Integer;
    readonly STATE_FOCUS: Integer;
    readonly STATE_VISITED: Integer;
    readonly STATE_CURRENT: Integer;
    readonly STATE_CHECKED: Integer;
    readonly STATE_DISABLED: Integer;
    readonly STATE_READONLY: Integer;
    readonly STATE_EXPANDED: Integer;
    readonly STATE_COLLAPSED: Integer;
    readonly STATE_INCOMPLETE: Integer;
    readonly STATE_ANIMATING: Integer;
    readonly STATE_FOCUSABLE: Integer;
    readonly STATE_ANCHOR: Integer;
    readonly STATE_POPUP: Integer;
    readonly STATE_OWNS_POPUP: Integer;
    readonly STATE_EMPTY: Integer;
    readonly STATE_BUSY: Integer;

    /**
     *
     Static constructor of DOM elements. object here is an object literal with microformat defined below.

     Example, following fragment is an equivalent of creating element with the markup <p>before <button>Hi!</button> after</p>:

     var para = Element.create { p, "paragraph text" }; // or if text is a variable:
     var para = Element.create { p, [paragraphText] };
     * @param {Object} object
     * @returns {Element}
     */
    create(object: Object): Element;
}

declare const self: Element;

interface Element extends StaticElement {
    /** number of child elements in this element. Read-only property. */
    readonly length: Integer;

    /** child element of the element at the index position, Read-write index accessor. Zero-based index. */
    [i: number]: Element;

    /** root element of the DOM this element belongs to. Read-only. */
    readonly root: Element;
    /** parent view (window) of the element. Read-only. Note: element.view  may not be equal to global view  variable if the element was moved from one view to another. */
    readonly view: View;
    /** parent element of given element or null if this element is a root element. Read-only. */
    readonly parent: Element;
    /** layout parent element of given element or null if this element is a root element. Read-only.
     For positioned elements (position:absolute) layout parent is the positioned container (closest positioned ancestor) element that is used for top/left/bottom/right calculations. */
    readonly layoutParent: Element;
    /** owner element of given element or null if this element is a root element. Read-only.
     Most of the time the owner is the parent but for popup elements for example owner is the element that owns the popup, e.g. for the tooltip element the owner is the element that causes the tooltip to be shown. */
    readonly owner: Element;
    /** index of the element in parent collection. Undefined if this element is not connected to any parent. */
    readonly index: Integer;
    /** tag name of the element. Read-only. */
    readonly tag: String;
    /** value of attribute id (if any). Read-only. */
    readonly id: String;
    /** next sibling element of the element or null if this is last element in the parent collection. */
    readonly next: Element;
    /** previous sibling element of the element or null if this is first element in the parent collection. */
    readonly prior: Element;
    /** first child (element) of the element or null if there are no children. */
    readonly first: Element;
    /** last child (element) of the element or null if there are no children. */
    readonly last: Element;
    /** collection of html attributes of the element. */
    attributes: Attributes;
    /** short form to accessAttributes, collection of html attributes of the element. It is just an alias of the attributes above. */
    //@: Attributes;
    /** style attributes of the DOM element. */
    style: Style;
    /** collection of states (runtime flags) of the DOM element. */
    state: States;
    /** Extenders, interface to collection of native behaviors attached to the element:
     element.x.length – reports number of native behaviors attached to the element;
     element.x[n] – reports name of n-th native behavior attached to the element.
     element.x.funcname(….) – call of methods implemented by native behaviors. */
    x: Extenders;
    /** text of the element. For compound elements this property returns plain-text version of the content */
    text: String;
    /** (inner HTML) html source of the content of the element. Text returned (String) will not include head and tail tags of the element. Value to set can be either String or Stream object. */
    html: String;
    /** (outer HTML) html source of the element. Text returned (String) will include head and tail tags of the element.
     Value to set can be either String or Stream object. */
    outerHtml: String;
    /** String by default and if the element has native behavior attached to the element it could be also: integer, boolean, array, etc. For example <input type="radio"> will return true if this radio button has "on" state.
     Note: property value(v) can be overriden in a behavior class in script. To access native value in such case use Element.state.value property. */
    value: String;
    /** Either Instance of Behavior or Element class object. Prototype can be set to the element through CSS (prototype:name_of_global_behavior_variable) or using this property. */
    prototype: Behavior | Element;
    /** true if element and all its containers are in visible state – no visibility:hidden or display:none defined for them. false – otherwise. */
    readonly isVisible: boolean;
    /** true if element and all its containers are not in :disabled state ( setState(Element.STATE_DISABLED)). */
    readonly isEnabled: boolean;
    /** namespace object of the element. All static functions and classes defined in scripts of current document are members of this [namespace] object. */
    readonly ns: Object;
    /** Number of rows in the DOM element, for the <table> element returns number of rows in it, for other returns number of rows with respect of flow CSS property. */
    readonly rows: Integer;
    /** Number of columns in the DOM element, for the <table> element returns number of columns in it, for other returns number of columns with respect of flow CSS property. */
    readonly columns: Integer;
    /** for <select> element returns DOM element – container of options that can be used to populate list of options programmatically. */
    readonly options: Element;
    /** Reports current content model of the element (as it defined in HTML5 spec) as one of:
     #block-inside – the element can contain block elements (e.g. <div>)
     #inline-inside – the element can contain inline elements (e.g. <p>).
     #transparent – the content model of a transparent element is derived from the content model of its parent element (e.g. <a>).
     #text-only – the element can contain only plain text (e.g. <title>).
     #table, #table-section and #table-row – <table>, <tbody>, <tfoot>, <thead> and <tr> elements. */
    readonly contentModel: Symbol;
    /** returns Selection object if the element has behavior (htmlarea or richtext) supporting selection functionality. */
    readonly selection: null | Selection;
    /** returns bookmark of first caret position inside the element. */
    readonly firstCaretPos: null | Bookmark;
    /** returns bookmark of last caret position inside the element. */
    readonly lastCaretPos: null | Bookmark;
    /** assigns background layer painting function. The function gets Graphics object that is used to draw the layer. If the function returns true then default background and borders drawing is suppressed. The background drawing function is drawn before native background drawing. */
    paintBackground: (gfx: Graphics) => boolean | null;
    /** assigns content layer painting function. The function gets Graphics object that is used to draw the layer. If the function returns true then default content drawing is suppressed. The content drawing function gets invoked before native content drawing. */
    paintContent: (gfx: Graphics) => boolean | null;
    /** assigns foreground layer painting function. The function gets Graphics object that is used to draw the layer. If the function returns true then default foreground drawing is suppressed. The content drawing function gets invoked before native foreground drawing. */
    paintForeground: (gfx: Graphics) => boolean | null;
    /** assigns outline layer painting function. The function gets Graphics object that is used to draw the layer. If the function returns true then default outline drawing is suppressed. The outline drawing function gets invoked before native outline drawing. */
    paintOutline: (gfx: Graphics) => boolean | null;
    /** assigns hit tester function. The function gets x,y coordinate and returns true if the point is inside the element shape. This allows to support elements with arbitrary shape. */
    isPointInside: (x: Integer, y: Integer) => boolean | null;
    /** index of the node in parent nodes collection. */
    readonly nodeIndex: Integer;
    /** next sibling node of the node or null if this is the last element in parent collection. */
    readonly nextNode: Element | Node;
    /** previous sibling node of the node or null if this is the first node in it’s parent’s collection. */
    readonly priorNode: Element | Node;
    /** reference to first child node (element, text, comment) of the element. */
    readonly firstNode: Element | Node;
    /** reference to last child node (element, text, comment) of the element. */
    readonly lastNode: Element | Node;
    /** true if this node is an element, false – otherwise. */
    readonly isElement: boolean;
    /** true if the node is a text node. */
    readonly isText: boolean;
    /** true if the node is a comment node. */
    readonly isComment: boolean;
    /** mouse events */
    onMouse: (evt: Event) => boolean;
    /** keyboard events */
    onKey: (evt: Event) => boolean;
    /** scroll events */
    onScroll: (evt: Event) => boolean;
    /** focus events */
    onFocus: (evt: Event) => boolean;
    /** logical (synthetic) events like Event.BUTTON_CLICK */
    onControlEvent: (evt: Event) => boolean;
    /** system drag-n-drop events like Event.X_DRAG */
    onExchange: (evt: Event) => boolean;
    /** touch events */
    onGesture: (evt: Event) => boolean;
    /** editing commands events */
    onCommand: (evt: Event) => boolean;

    new(tagname: String | Symbol, text?: String): Element;

    /**
     * Clears a content of the element, removing all its children.
     * @returns {undefined}
     */
    clear(): undefined;

    /**
     *Returns string – html representation of the element. Text returned is outer html – includes head and tail tags and content s equal to text returned by В html attribute.
     * @returns {String}
     */
    toString(): String;

    /**
     *Returns new copy of the element. Method performs a deep copy of the element. New element is disconnected from the DOM state. Use insert() method to include it in the DOM.
     * @returns {Element}
     */
    clone(): Element;

    /**
     *
     Returns first element satisfying CSS selector (CSSselector, string). CSSSelector may contain format specifiers like %d, %s which will be substituted by values of argument1 … argumentN in final CSS selector string. Function uses the same rules as does Stream.printf function.

     Example, if document contains <input type="text"/> element then following statement

     var inp = self.select("input[type='text']");
     will set inp by reference to such element.
     * @param {String} CSSselector
     * @param args
     * @returns {Element}
     */
    select(CSSselector: String, ...args: any[]): Element;

    /**
     *
     Returns first element satisfying CSS selector.

     Note: this is a "stringizer" method so CSS selector can В be written without "" quotes.

     Example, if document contains <input type="text"/> elements then following statement

     var inp = self.$( input[type='text'] );
     will set inp by reference to such element.

     And the following fragment:

     var n = 3;
     var li3 = self.$( ul > li:nth-child({n}) );
     will find third list item in ul list element.
     * @param CSSselector
     * @returns {Element}
     */
    $(CSSselector): Element;

    /**
     *
     Calls func (function reference) for each element satisfying (matching) CSSselector. Function func shall accept one parameter where select will provide reference to matched element. Function may return true to stop enumeration.

     Example, following fragment will print out names of all input elements in the document:
     function printel(el) { В stdout.println( el.attributes["name"] ); В }
     document.select(printel, "input");
     * @param func
     * @param {String} CSSselector
     * @param args
     * @returns {Integer}
     */
    select(func, CSSselector: String, ...args: any[]): Integer;

    /**
     *Returns array of elements satisfying CSS selector (CSSselector, string). CSSSelector may contain format specifiers like %d, %s which will be substituted by values of argument1 … argumentN in final CSS selector string. Function uses the same rules as does Stream.printf function.
     * @param {String} CSSselector
     * @param args
     * @returns {Array}
     */
    selectAll(CSSselector: String, ...args: any[]): Array;

    /**
     *
     Returns array of elements satisfying CSS selector (CSSselector, string).

     Note: this is a stringizer method – the CSSselector provided literally.
     * @param CSSselector
     * @returns {Array}
     */
    $$(CSSselector): Array;

    /**
     *Returns first element in child/parent chain satisfying CSS selector (CSSselector, string). CSSSelector may contain format specifiers like %d, %s which will be substituted by values of argument1 … argumentN in final CSS selector string. Function uses the same rules as does Stream.printf function.

     ATTN: Function also inspects this element.
     * @param {String} CSSselector
     * @param args
     * @returns {Element}
     */
    selectParent(CSSselector: String, ...args: any[]): Element;

    /**
     *
     Returns first element in child/parent chain satisfying CSS selector.

     Note 1: this is a stringizer method – the CSSselector provided literally.

     Note 2: Function also inspects this element.
     * @param CSSselector
     * @returns {Element}
     */
    $p(CSSselector): Element;

    /**
     *
     Returns first owner element in child/parent chain satisfying CSS selector.

     Note 1: this is a stringizer method – the CSSselector provided literally.

     Note 2: Function also inspects this element.

     Note 3: Most of the time element’s owner is is its parent except of popup menus when the owner is the element requested the popup.
     * @param CSSselector
     * @returns {Element}
     */
    $o(CSSselector): Element;

    /**
     *
     Calls func (function reference) for each element satisfying (matching) CSSselector. Function func shall accept one parameter where select will provide reference to matched element. Function may return true to stop enumeration.

     Example, following fragment will print out ids of all parent divs of some element:

     function printel(el) {  stdout.println( el.attributes["id"] );  }
     some.selectParent(printel, "div");
     Note: Function also inspects this element.
     * @param func
     * @param {String} CSSselector
     * @param args
     * @returns {Integer}
     */
    selectParent(func, CSSselector: String, ...args: any[]): Integer;

    /**
     *
     Returns array of references of elements in child/parent chain satisfying CSS selector.

     Note 1: this is a stringizer method – the CSSselector provided literally.

     Note 2: Function also inspects this element.
     * @param CSSselector
     * @returns {Element[]}
     */
    $$p(CSSselector): Element[];

    /**
     *Checks if this DOM element satisfies given CSSselector.
     * @param {String} CSSselector
     * @param args
     * @returns {boolean}
     */
    match(CSSselector: String, ...args: any[]): boolean;

    /**
     *
     Checks if this DOM element satisfies given CSSselector.

     Note: this is a stringizer method – the CSSselector provided literally.
     * @param CSSselector
     * @returns {boolean}
     */
    $is(CSSselector): boolean;

    /**
     *
     Returns true if this element is has parent in its ancestor chain. If useUITree is provided and it is true then the function uses UI relationship rather than strict DOM parent/children relation. For example popup element can be declared outside of its host element but this function returns true for the popup if it was created for this element.

     If includingThis is defined and is true then this function returns true for the element itself too : el.belongsTo(el,false,true) -> true. By default includingThis is false.
     * @param {Element} parent
     * @param {boolean} useUITree
     * @param {boolean} includingThis
     * @returns {boolean}
     */
    belongsTo(parent: Element, useUITree?: boolean, includingThis?: boolean): boolean;

    /**
     *Returns reference to the child of the given element at x,y coordinates relative to the origin of the element. If there is no such element method returns element itself.
     * @param x
     * @param y
     * @returns {Element}
     */
    find(x, y): Element;

    /**
     *Remeasures given element (if deep == true) and invalidates its visual area after modifications. Use deep=true value if element will get new dimensions due to some operations on it. Omit deep parameter (or set it to false) if only decoration attributes (not changing dimensions, like color) were changed.
     * @param deep
     * @returns {undefined}
     */
    update(deep?): undefined;

    /**
     *
     That is "transactioned update". The stateUpdateFunction is called with this variable set to the element object and is expected to contain code that modifies state of the element, its content or states of its subelements.

     "transactioned update" mechanism is used when the element is expected to have "content" transitions defined in CSS as transition:blend(), scroll-***(), slide-***(), etc.

     The Element.update(stateUpdateFunction) does these steps:

     Makes snapshot of intial state of the element;
     Calls provided stateUpdateFunction() function that is expected to make all needed changes for the new state of the element;
     Makes final state snapshot;
     Starts the transitioning animation (if it is defined in CSS for the element) using these two snapshots.
     If there is no CSS transition defined for the element then stateUpdateFunction() is called and view is updated to the new state of the element immediately.
     * @param stateUpdateFunction
     * @returns {undefined}
     */
    update(stateUpdateFunction): undefined;

    /**
     *Invalidates area occupied by the element on the screen. If x , y, width, height (coordinates of area inside element) are provided then it invalidates only that portion. This method is useful if you are using Graphics for rendering on element surface area.
     * @param x
     * @param y
     * @param width
     * @param height
     * @returns {boolean}
     */
    refresh(x?, y?, width?, height?): boolean;

    /**
     *
     Starts animation on the element. nextStep is a function that executes animation step (changes dimension, opacity, etc.). This function is called with this set to the element itself and should return:

     true – to continue animation with system defined FPS;
     integer – milliseconds, delay to next animation step call, if 0 stop animation;
     duration – delay to next animation step call, stop animation if the duration is zero;
     false – stop animation;
     If whenEnded function is provided it will be called on the end of the animation.

     The duration is total duration of the animation in milliseconds. If it is provided then signature of the nextStep function is expected to be:

     function nextStep(progress: float) {}
     where progress is a float number from 0.0 to 1.0 – progress of the animation. The nextStep function will always receive progress == 1.0 as the very last step.

     Otherwise step callback function is expected to have no parameters:

     function nextStep() {}
     * @param {(progress?: Float) => boolean} nextStep
     * @param {Function} whenEnded
     * @param {Duration | Integer} duration
     * @returns {undefined}
     */
    animate(nextStep: (progress?: Float) => boolean, whenEnded?: Function, duration?: Duration | Integer): undefined;

    /**
     *
     Returns coordinates of the edges of the element. Parameters:

     part – one of symbolic constants #left, #top, #right, #bottom, #width or #height. Defines part of box (rectangle) to return.
     If part is #rect then the function returns four values – left, top, right, bottom. Use it for example as
     var (x1,y1,x2,y2) = this.box(#rect, #inner, #view);
     If part is #rectw then the function returns four values – left, top, width and height. Use it for example as
     var (x,y,w,h) = this.box(#rectw, #inner, #view);
     If part is #dimension the function returns two values – width and height. Use it as:
     var (w,h) = this.box(#dimension, #inner);
     If part is #position the function returns two values – left and top. Use it as:
     var (x,y) = this.box(#position, #inner, #view);
     edge, one of edges of element:
     #margin – margin box edge,
     #border – border box edge,
     #padding – padding box edge,
     #inner, default value – inner box edge,
     #content – content box edge. Content box here is outline of the content of the element and this is not В an inner box of the element. E.g. content box can be bigger than inner box if the element has overflow attribute set.
     #client – client area, that is #inner box minus areas taken by [optional] scrollbars.
     #icon -area covered by element’s icon. Icon here is element’s foreground image with foreground-repeat: no-repeat. If element has no such image the function returns #width and #height equals to zero.
     relativeTo, one of:
     #screen – returns coordinate relative to the origin of the screen,
     #root – returns coordinate relative to the origin of root element (view),
     #parent – returns coordinate relative to the origin of its parent element. Note: parent scroll position relative.
     #content – returns coordinate of the element in content of its parent. Note: is not dependent on parent scroll position.
     #container – returns coordinate of the element relative to layout parent. Layout parent can be different from DOM parent element. E.g. position:absolute elements may have positioning layout parent different from DOM parent.
     #self, default value – all coordinates are relative to the origin of inner box of the element.
     #view – returns coordinate relative to the origin of the sciter window (view object).
     or if relativeTo equals one of the following values:
     #margin – margin box edge,
     #border – border box edge,
     #padding – padding box edge,
     #inner – inner box edge
     the function will return cumulative widths of correspondent parts, examples:

     var (mx1,my1,mx2,my2) = this.box(#rect, #margin, #inner);
     Each mx* value here will get sum of margin, border and padding in the left, top, right and bottom directions. In other words this call will return distances of margin box from inner(content) box of the element. And this call var (mx1,my1,mx2,my2) = this.box(#rect, #margin, #border); will just return computed values of margin-left, margin-top, margin-right and margin-bottom CSS attributes.

     For more information see the CSS box model specification: http://www.w3.org/TR/CSS2/box.html
     * @param part
     * @param edge
     * @param relativeTo
     * @returns {Integer}
     */
    box(part, edge?, relativeTo?): Integer;

    /**
     *returns min-intrinsic width of the element. min-intrinsic width is minimal width needed to show element without horizontal scrollbar.
     * @returns {Integer}
     */
    intrinsicWidthMin(): Integer;

    /**
     *returns max-intrinsic width of the element. max-intrinsic width is minimal width needed to show element without wrapping, e.g. for the <p> element this will be width of its text replaced in single line.
     * @returns {Integer}
     */
    intrinsicWidthMax(): Integer;

    /**
     *returns min-intrinsic height of the element for the given forWidth. min-intrinsic heigh is minimal height needed to show element without vertical scrollbar.
     * @param {Integer} forWidth
     * @returns {Integer}
     */
    intrinsicHeight(forWidth: Integer): Integer;

    /**
     *
     returns the length value converted to the number of device pixels. Conversion is made in context of current element style so el.toPixels( em(1.4) ) will number of pixel correspond to 1.4em that us dependent on current font size of the element.

     length is a string or symbol then this string is treated as a CSS length literal so it is possible to get values like: el.toPixels(#xx-small) В or el.toPixels(#system-scrollbar-width),

     Second symbol parameter is used with the conversion from perecentage lengths:
     var h50p = el.toPixels( pr(50.0), #height ); – will calculate the same value as the following CSS declaration: height:50%.
     * @param {length | String | symbol} length
     * @param {Symbol} side
     * @returns {Integer}
     */
    toPixels(length: length | String | symbol, side?: Symbol): Integer;

    /**
     *
     Returns various scrolling related positions of the element. Parameters:

     part – one of symbolic constants:

     #left – left position of the view relative to content origin,
     #top – top position,
     #right – offset of right edge of the view from right edge of the content box,
     #bottom – offset of bottom edge of the view from bottom edge of the content box,
     #width – width of scrollable area,
     #height – height of scrollable area.
     #rect – returns left,top,right,bottom positions as four integers.
     * @param part {Symbol}
     * @returns {Integer}
     */
    scroll(part: Symbol): Integer;

    /**
     *Sets scroll position of the element to x,y position. The element should have overflow: hidden-scroll, scroll or auto to be able to scroll its content. If unrestricted is set to true then scroll poistion is allowed to be out of content boundaries.
     * @param {Integer} x
     * @param {Integer} y
     * @param {bool} smooth
     * @param {bool} unrestricted
     */
    scrollTo(x: Integer, y: Integer, smooth?: bool, unrestricted?: bool): void;

    /**
     *Scrolls the element to the view – ensures that element is visible. В If toTop is true then forces element to be on top of its scrollable container. This method does deep scroll – it tries to make the element visible through all its scrollable containers. If smooth is false then no attempt to animate the scrolling will be made.

     NOTE: in order that method to work the element should establish a box – to be of display: block | inline-block | table-cell | etc. In contrary <tr> (table row) for example is not a box element. In order to scroll to particular row in table you should choose first cell in that row.
     * @param {bool} toTop
     * @param {bool} smooth
     */
    scrollToView(toTop?: bool, smooth?: bool = true);

    /**
     *maps xLocal/yLocal point of the element to xView/yView (window) coordinates with respect of CSS tranformations.
     * @param {Integer} xLocal
     * @param {Integer} yLocal
     * @returns {MultipleReturnValue}
     */
    mapLocalToView(xLocal: Integer, yLocal: Integer): MultipleReturnValue; //Integer,Integer;

    /**
     *maps xView/yViewl point of the view into xLocal/yLocal (element) coordinates with respect of CSS tranformations.
     * @param {Integer} xView
     * @param {Integer} yView
     * @returns {MultipleReturnValue}
     */
    mapViewToLocal(xView: Integer, yView: Integer): MultipleReturnValue; //Integer,Integer;

    /**
     *element is a child DOM element (instance of this Element class) to be inserted at the index position. If index is greater than current number of children in this element then new element will be appended as a last element. Index is optional parameter, if ommited then element will be appended to collection. If element is already a child of some other parent then it will be disconnected from it automaticly.

     If first parameter is string (html text) then attempt will be made to insert it at given position.

     If first parameter is an object then it is considered as a template for creation of new DOM element. Microformat of that object is defined below.

     If first parameter is an array it shall contain DOM Node references (elements and/or text nodes).
     * @param {Element | String | Object | Array} what
     * @param {Integer} index
     * @returns {boolean}
     */
    insert(what: Element | String | Object | Array, index?: Integer): boolean;

    /**
     *Equivalent of insert ( ... , Integer.MAX );
     * @param {Element | String | Object | Array} what
     * @returns {boolean}
     */
    append(what: Element | String | Object | Array): boolean;

    /**
     *Equivalent of insert ( ... , 0 );
     * @param {Element | String | Object | Array} what
     * @returns {boolean}
     */
    prepend(what: Element | String | Object | Array): boolean;

    /**
     *
     Replaces content of the element by elements, that is short form of el.clear(); el.append(element1); el.append(element2); ...

     This method can be used for setting cells in <tr>s. It handles properly cells with col/rowspans.

     For all other elements elementN can be either DOM element, string, object ( template of the element that uses microformat ) or array of Elements/Nodes.
     * @param {Element | Array} what
     * @param {Element[]} elements
     * @returns {boolean}
     */
    content(what: Element | Array, elements?: Element[]): boolean;

    /**
     *Stringizer method, replaces content of the element by the inline html. As this is a stringizer method then html can be provided as it is, example:

     var el = ... , num = ...;
     el.$content(This is item number { num });
     Method returns the element itself.
     * @param inlineHtml
     * @returns {Element}
     */
    $content(inlineHtml: any): Element;

    /**
     *Stringizer method, adds content defined by the inline html to the end of the list of children of the element.

     Method returns first added element.
     * @param html
     * @returns {Element}
     */
    $append(html: any): Element;

    /**
     *
     Stringizer method, insert content defined by the inline html at the start of children list of the element.

     Method returns first added element.
     * @param html
     * @returns {Element}
     */
    $prepend(html: any): Element;

    /**
     *
     Stringizer method, adds content defined by the inline html to the parent of the element immediately after this one.

     Method returns first added element.
     * @param html
     * @returns {Element}
     */
    $after(html: any): Element;

    /**
     *
     Stringizer method, insert content defined by the inline html to the parent of the element immediately before this one.

     Method returns last added element (that will be new this.prior element).
     * @param html
     * @returns {Element}
     */
    $before(html: any): Element;

    /**
     *
     Stringizer method, removes this element from the DOM and content defined by the html in its place.

     Method returns first added element.
     * @param html
     * @returns {Element}
     */
    $replace(html: any): Element;

    /**
     *Method creates an array and populates it by list of child DOM nodes. Text and comment nodes are represented by instance of Node object and elements by the Element.
     * @returns {Array}
     */
    nodes(): Array;

    /**
     *Removes this element from its parent’s children collection so after call of this method this.parent become null. If update is true then calls update() for the parent element. Returns element that was just detached (this). This method does not destroy state and behaviors attached to the element until GC will not collect the element (if there are no references to it)
     * @returns {Element}
     */
    detach(): Element;

    /**
     *Removes this element from its parent’s children collection so after call of this method this.parent become null. If update is true then calls update() for the parent element. Returns element that was just detached (this). All runtime states and behaviors are destroyed by the method. Native behaviors will receive BEHAVIOR_DETACHED event.
     * @returns {Element}
     */
    remove(): Element;

    /**
     *
     Loads content of the document referred by url as a content of this element. For elements having behavior:frame assigned it loads html, styles and executes scripts refered by the url or contained in the stream. Upon completion of loading behavior:frame posts DOCUMENT_COMPLETE event. For any other elements it loads only content of body portion of the document, no style loading or script execution happens in this case. If the url points on external resource like "http://…" then the method is asynchronous. Otherwise it tries to load the resource synchronously.

     If headers object ( name/value map) is present and url is http/https then HTTP GET request is sent with those headers.
     * @param {String} url
     * @param {Object} headers
     * @returns {boolean}
     */
    load(url: String, headers?: Object): boolean;

    /**
     *Loads content of the document from in-memory stream as a content of this element. For elements having behavior:frame assigned it loads html, styles and executes scripts referred by the URL or contained in the stream. For any other elements it loads only content of body portion of the document, no style loading or script execution happens in this case.
     * @param {Stream} stream
     * @returns {boolean}
     */
    load(stream: Stream): boolean;

    /**
     *Loads the html document from string as a content of this element. For elements having behavior:frame assigned it loads html, styles and executes scripts refered by the the html content. For any other elements it loads only content of body portion of the document, no style loading or script execution happens in this case.
     * @param {String} html
     * @param {String} url
     * @returns {boolean}
     */
    load(html: String, url: String): boolean;

    /**
     *
     This function parses given HTML (or SVG) string or stream and returns either:

     Root DOM element if the input starts from "<html>..." or "<svg>..." or
     List of parsed nodes or elements if the input is HTML fragment like "<i>Some</i><b>text</b>"
     If the html string starts from file:// sequence then it is treated as an URL of file to parse.

     Note that parsed DOM elements/nodes that the function returns are not connected to the host document.
     * @param {String | Stream} html
     * @returns {Element | Node[]}
     */
    parseHtml(html: String | Stream): Element | Node[];

    /**
     *
     Loads image from the url. If callback is ommited then the engine will try to load image sycnhronously otherwise (if callback is a function) engine will issue asynchronous request and will call this function upon arrival.

     If useCache is not false then the method will try to use image cache to get the image and on successful download the image will go to the cache too. By default useCache is false.

     Signature of the callback function is function callback(image, status) where image is an object of class Image or null in case of error, status is http status (200,404,etc).
     * @param {String} url
     * @param {Function} callback
     * @param {boolean} useCache
     * @returns {Image | null}
     */
    loadImage(url: String, callback?: Function, useCache?: boolean): Image | null;

    /**
     *Binds the img with the URL. As a result the image can be used in CSS for example as a background. URL can be any arbitrary unique string here, like "in-memory:dyn-image1".
     * @param {String} url
     * @param {Image} img
     * @returns {boolean}
     */
    bindImage(url: String, img: Image): boolean;

    /**
     *Returns image that was previously bound with the URL or null if there is no such image.
     * @param {String} url
     * @returns {Image | null}
     */
    bindImage(url: String): Image | null;

    /**
     *string [, params: object [, headers: object] ] ) : Object | Stream | Bytes | Error
     Sends synchronous or asynchronous http data GET/POST request to the server/page (url), a.k.a. JSON-RPC calls.

     #get, #post, #post-data #json are literal symbols – type of http request to be sent:
     #get – sends plain HTTP GET request, url-encoded params (if any) are appended to the url to form the request;
     #post – sends HTTP POST request with params serialized as Content-Type: application/x-www-form-urlencoded;charset=utf-8;
     #post-data – sends HTTP POST request with params serialized as Content-Type: multipart/form-data; boundary= ...;
     #put-data – sends HTTP PUT request with params serialized as Content-Type: multipart/form-data; boundary= ...;
     #post-json – sends HTTP POST request with params serialized as JSON, В Content-Type: application/json;charset=utf-8;
     #put-json – sends HTTP PUT request with params serialized as JSON, Content-Type: application/json;charset=utf-8;
     #delete – – sends HTTP DELETE request.
     url is a string – url of the page (location) on the server handling HTTP requests.
     params is an object, its properties are serving role of parameters of HTTP request.
     headers is an object – a map of additional header key/value pairs to send along with the request.
     returns: true|false for asynchronous requests or pair of (status:integer,data:any) – result of the request (see data below) and HTTP status code (e.g. 200 – OK, 404 – resource was not found on the server).
     If parameter callback is an integer than it is treated as a timeout value (number of milliseconds) and the function executes synchronous request. If the callback is a function then response from the server will be delivered by calling the callback function having following signature:
     function dataArrivedCallback( data: any, status: integer );
     where data is either one of:

     instanceof Error object, in case of data response parsing problems;
     stream, if data returned by the server is of textual type (text/plain, text/html, text/xml, etc.)
     instanceof Object, Array, etc. if response has content type text/javascript, text/ecmascript, text/tiscript or application/json and was successfully parsed into data object.
     Bytes, if data returned by the server is of binary type (image/*, etc.). Bytes.type in this case will contain a string – mime-type of the data reported by the server.
     and status code is an integer – HTTP status code (e.g. 200 – OK, 404 – resource was not found on the server) or if code is greater than 12000 it is a WinInet error code, see: http://support.microsoft.com/kb/193625.

     Example of server data response (type: text/javascript) :

     ({ id : 1234, message : "Hello from XYS server!" })

     – in this case server returns object having two properties: id and message. Rationale behind of ({ and }) was explained here.
     * @param {(data: any, status: Integer) => (void | Integer)} callback
     * @param {Symbol} method
     * @param {String} url
     * @param {Object} params
     * @param {Object} headers
     * @returns {Object | Stream | Bytes | Error}
     */
    request(callback: (data: any, status: Integer) => void | Integer, method: Symbol, url: String, params?: Object, headers?: Object): Object | Stream | Bytes | Error;

    /**
     *Returns state of the element. stateFlags here is a set of bits – "ORed" constants STATE_***. stateFlags is provided then function returns int – flags of the element ANDed with the provided stateFlags variable. If no stateFlags is given then the function returns full set of flags element has at hte moment.
     * @param {Integer} stateFlags
     * @returns {Integer}
     */
    getState(stateFlags?: Integer): Integer;

    /**
     *Function will set flags to the element update document on the screen accordingly (resolve styles and refresh).
     * @param {Integer} stateFlags
     */
    setState(stateFlags: Integer): void;

    /**
     *Function will clear flags of the element and update document on the screen.
     * @param {Integer} stateFlags
     */
    clearState(stateFlags: Integer): void;

    /**
     *element.capture(true) – sets "soft" mouse capture to the element, mouse messages are delivered to the element and its children;
     element.capture(#strict) – sets "strict" mouse capture to the element, mouse messages are delivered to the element only;
     element.capture(false) – removes mouse capture from the element.
     * @param {boolean | strict} onOff
     * @returns {Symbol}
     */
    capture(onOff: boolean | Symbol): void;

    /**
     *
     Function will show element el as a popup window placed relatively to this element. Placement is a combination of two values from two groups:

     Point on this element ( a.k.a. popup anchor point )

     1 – this element’s bottom-left point
     2 – this element’s bottom-center point
     3 – this element’s bottom-right point
     4 – this element’s center-left point
     5 – this element’s middle-center point
     6 – this element’s middle-right point
     7 – this element’s top-left point
     8 – this element’s top-center point
     9 – this element’s top-right point
     Point on popup to be placed at the anchor point:

     1 << 16 – popup bottom-left is at anchor point
     2 << 16 – popup bottom-center is at anchor point
     3 << 16 – popup bottom-right is at anchor point
     4 << 16 – popup center-left is at anchor point
     5 << 16 – popup middle-center is at anchor point
     6 << 16 – popup middle-right is at anchor point
     7 << 16 – popup top-left is at anchor point
     8 << 16 – popup top-center is at anchor point
     9 << 16 – popup top-right is at anchor point
     ( see keyboard numpad to get an idea of numbering).
     Alternatively you can use "popup auto flip" positioning modes:

     0x19 – popup appears on the left of anchor by default. If space on screen does not allow then popup is replaced on the right of anchor (as 0x17). Vertical alignment – top of popup to the top of anchor.
     0x17 – popup appears on the right of anchor by default, otherwise on the left. Vertical alignment – top of popup to the top of anchor.
     0x16 – popup appears on the left of anchor by default. If space on screen does not allow then popup is replaced on the right of anchor (as 0x14). Vertical alignment – middle of popup to the middle of anchor.
     0x14 – popup appears on the right of anchor by default, otherwise on the left. Vertical alignment – middle of popup to the middle of anchor.
     placement parameter is optional. The popup position can also be defined in CSS  by popup-position property.
     * @param {Element} el
     * @param {Integer} placement
     */
    popup(el: Element, placement?: Integer): void;

    /**
     *
     Function will show element el as a popup window placed at x, y (view relative coordinates). Placement defines what point of the el shall be places at x,y. By default it is 7 (top/left corner).

     ( see keyboard numpad to get an idea of numbering).
     * @param {Element} el
     * @param {Integer} placement
     * @param {Integer} x
     * @param {Integer} y
     */
    popup(el: Element, placement?: Integer, x?: Integer, y?: Integer): void;

    /**
     *Function will close popup if element el or any of its parent is a popup window.
     */
    closePopup(): void;

    /**
     *
     If milliseconds is greater than zero the method will create timer for the DOM element with milliseconds delay.

     After milliseconds delay engine will call callback function with this variable set to the dom element. Return true from the callback() function if you need to continue timer ticks and false otherwise.

     Call of timer() with milliseconds = 0 parameter will stop the timer.

     If the element already contains running timer with function of the same oringin as the callback then that timer gets removed before adding new timer. Passing true as avoidSameOriginCheck parameter will suppress same origin matching.
     * @param {Integer} milliseconds
     * @param {() => boolean} callback
     * @param {bool} avoidSameOriginCheck
     */
    timer(milliseconds: Integer, callback: () => boolean, avoidSameOriginCheck?: bool);

    /**
     *Swaps DOM positions of two elements – owner of the method and the other. Returns element whose method is called.
     * @param {Element} other
     * @returns {null}
     */
    swap(other: Element): null;

    /**
     *traverse (send) bubbling event to the parent/child chain of this element. Events generated by this method can be handled by onControlEvent() methods of elements in the chain.

     eventCode is either one of constants from Logical event codes from builtin behaviors ( see: Event ) or any integer value above 0x1000 (custom control events range).
     reason here is an arbitrary integer value that sender and receiver knows about.
     owner is an optional reference to some DOM element. E.g. in MENU_ITEM_CLICK this is a reference to element – owner of popup menu or null.
     data is any json value that will passed to BEHAVIOR_EVENT_PARAMS.data field (see: sdk/api/sciter-x-behavior.h file)
     The sendEvent does traversal so it returns true if the event was consumed – one of onControlEvent() handlers in parent/child chain returned true while handling this event. If some element in child-parent chain consumes the event (returns true) and sets the data field the value of this updated data field will be returned from the sendEvent() function.
     * @param {Integer} eventCode
     * @param {Integer} reason
     * @param {Element | null} owner
     * @param {value} data
     * @returns {boolean | value}
     */
    sendEvent(eventCode: Integer, reason?: Integer, owner?: Element | null, data?: value): boolean | value;

    /**
     *
     traverse (send) bubbling event to the parent/child chain of this element. Events generated by this method can be handled by onControlEvent() methods of elements in the chain.

     event is an event name possibly with namespace, see Element.subscribe/unsubscribe() below.
     data is any json value that will passed to BEHAVIOR_EVENT_PARAMS.data field (see: sdk/api/sciter-x-behavior.h file). The data is also available as evt.data field in event handlers.
     The sendEvent does traversal so it returns true if the event was consumed – one of handlers in parent/child chain returned true while handling this event. If some element in child-parent chain consumes the event (returns true) and sets the data field the value of this updated data field will be returned from the sendEvent() function.
     * @param {String} event
     * @param {value} data
     * @returns {boolean | value}
     */
    sendEvent(event: String, data?: value): boolean | value;

    /**
     *The postEvent places event into the internal queue of posted events for future traversal by sendEvent(name,data) and returns immediately.
     * @param {String} event
     * @param {value} data
     * @returns {true}
     */
    postEvent(event: String, data?: value): true;

    /**
     *The postEvent places event into the internal queue of posted events for future traversal by sendEvent and returns immediately.
     * @param {Integer} eventCode
     * @param {Integer} reason
     * @param {Element | null} owner
     * @param {value} data
     * @returns {undefined}
     */
    postEvent(eventCode: Integer, reason?: Integer, owner?: Element | null, data?: value): undefined;

    /**
     *
     The sendKeyEvent simulates the key event. eventDef may have following fields:

     {
       type: Event.KEY_DOWN or Event.KEY_UP or Event.KEY_CHAR; // type if key event
       keyCode: int; // Key or char code, e.g. 'O'
       altKey: true or false; // optional, 'ALT' key pressed flag
       shiftKey: true or false; // optional, 'SHIFT' key pressed flag
       ctrlKey: true or false; // optional, 'CTRL' key pressed flag
       shortcutKey: true or false; // optional, 'CTRL/win' or 'COMMAND/mac' key pressed flag
       commandKey: true or false; // optional, 'WIN/win' or 'COMMAND/mac' key pressed flag
     }
     Function returns true if the event was consumed during sinking/bubbling dispatching of the event using this element as a target.
     * @param {Object} eventDef
     * @returns {boolean | undefined}
     */
    sendKeyEvent(eventDef: Object): boolean | undefined;

    /**
     *
     The sendMouseEvent simulates the mouse event. eventDef may have following fields:

     {
       type: Event.KEY_DOWN or Event.KEY_UP or Event.KEY_CHAR, // type if key event
       altKey: true or false, // optional, 'ALT' key pressed flag
       shiftKey: true or false, // optional, 'SHIFT' key pressed flag
       ctrlKey: true or false, // optional, 'CTRL' key pressed flag
       shortcutKey: true or false; // optional, 'CTRL/win' or 'COMMAND/mac' key pressed flag
       commandKey: true or false; // optional, 'win/win' or 'COMMAND/mac' key pressed flag
       mainButton: true or false, // optional, left mouse button pressed flag
       propButton: true or false, // optional, right mouse button pressed flag
       x: int, // x mouse coordinate, view relative
       y: int, // y mouse coordinate, view relative
     }
     Function returns true if the event was consumed during sinking/bubbling dispatching of the event using this element as a target.
     * @param {Object} eventDef
     * @returns {boolean | undefined}
     */
    sendMouseEvent(eventDef: Object): boolean | undefined;

    /**
     *
     This method allows to delay execution of callback function. While calling the callback function engine will set this environment variable to the element this post call was invoked with.

     Optional parameter only_if_not_there if defined and is true allows to post delayed event only once. Multiple post with the same callback function will yield to a single entry in posted events queue.
     * @param {Function} callback
     * @param {boolean} only_if_not_there
     * @returns {undefined}
     */
    post(callback: Function, only_if_not_there?: boolean): undefined;

    /**
     *Method builds absolute url from the relativeUrl by using document url as a base. В If there is no relativeUrl then the method just returns url of the document this DOM element belongs to.
     * @param {String} relativeUrl
     * @returns {String}
     */
    url(relativeUrl?: String): String;

    /**
     *
     Sorts children of the element by using comparator function. comparator function has to have following signature:

     function cmp(el1: Element, el2: Element) : int
     that returns negative int value if el1 is less than el2, 0 if they are equal and positive value if el1 is greater than el2.

     fromIndex and numOfElements are used for defining range of elements to sort.
     * @param {(a: Element, b: Element) => Integer} comparator
     * @param {Integer} fromIndex
     * @param {Integer} numOfElements
     */
    sort(comparator: (a: Element, b: Element) => Integer, fromIndex?: Integer, numOfElements?: Integer): void;

    /**
     *
     This methods transforms the element into the "sprite" – element that moves independently from the rest of the DOM:

     Declares element as having position:popup and moves it to the position (x,y). If the element happens to be outside of the view then engine creates special popup window for it. Third parameter describes role of x and y values. w and h parameters, if provided, change dimensions of the element.
     mode parameter

     #auto – window is created if element is moved outside of the view. If element stays inside the view it is rendered as popup:fixed.
     #attached-window – forces the engine to create popup window for the element, window is moved in sync with its host window (view).
     #detached-window – forces the engine to create popup window for the element, element’s window position is indpenedent from the host window.
     #detached-topmost-window – that is #detached-window but created on topmost window layer.
     relto tells what kind of coordinates x,y are: #view, #root, #screen or #self relative. Default – #view.

     referencePoint is a number from 1 to 9 – defines what x,y are cordinates of. 7 is top/left corner, 5 is center of the element, see numpad on keyboard. NOTE: if provided the referencePoint defines position of element’s border box.  In all other cases x/y defines position of top/left corner of cotent box.

     Samples are in sdk/samples/ideas/moveable-windows/ and sdk/samples/ideas/rect-tracker/ folders.

     Call of the move() without parameters restores default positioning of the element.

     See also: Element.style.dimension() method.
     * @param {Integer} x
     * @param {Integer} y
     * @param {Integer} w
     * @param {Integer} h
     * @param relto
     * @param mode
     * @param {Integer} referencePoint
     */
    move(x: Integer, y: Integer, w?: Integer, h?: Integer, relto?, mode?, referencePoint?: Integer): void;

    /**
     *Calculates width of the text with respect of current font defined for the element. If text contains multiple lines separated by "\n" character then it returns width of widest string.
     * @param {String} text
     * @returns {Integer}
     */
    textWidth(text: String): Integer;

    /**
     *Calculates height of the text with respect of current font and line-height defined for the element. If text contains multiple lines separated by "\n" character then it returns sum of heights of all strings.
     * @param {String} text
     * @returns {Integer}
     */
    textHeight(text: String): Integer;

    /**
     *
     Assigns the handler function to the particular event that may occur on this particular DOM object.

     handler function should have following signature function(evt) {…}, where evt is an Event object that describes the event in details.

     eventGroup here is one of the following constants:

     Event.MOUSE – group of mouse events (like Event.MOUSE_DOWN, Event.MOUSE_UP, etc. );
     Event.KEY – group of keyboard events (like Event.KEY_DOWN, Event.KEY_UP, etc. );
     Event.BEHAVIOR_EVENT – group of generated, synthetic events (a.k.a. control events like Event.BUTTON_CLICK, Event.HYPERLINK_CLICK, Event.BUTTON_STATE_CHANGED, etc. );
     Event.FOCUS – group of scroll events;
     Event.SCROLL – group of scroll events;
     Event.SIZE – size changed event;
     eventType here is one of constants defined below for particular group of event. eventType parameter is optional – if it is not provided then the handler function will receive all events of the eventGroup.

     subscribe() method allows to attach multiple and independent event handling functions to single element.

     Note that subscribe() is not a substitution of onMouse(evt), onKey(evt), etc. event handlers defined below. These two ways of handling events work side-by-side. onXXXX() methods are used for defining event handlers in classes (Behaviors) so to handle events for classes of elements. And subscribe()/unsubscribe() are used for attaching event handlers to particular elements.

     Method returns the element it was called for. This allows to chain subscribe() calls.
     * @param {(evt: Event) => boolean} handler
     * @param {Integer} eventGroup
     * @param {Integer} eventType
     * @returns {Element}
     */
    subscribe(handler: (evt: Event) => boolean, eventGroup: Integer, eventType?: Integer): Element;

    /**
     *
     Assigns the handler function to the particular event that may occur on this DOM object or on one of its children. The event here is a string that can accept symbolic event names.

     Event names may have namespaces in their names. For example: "click.mywidget" defines click handler assigned by some mywidget component. Namespaces are especially useful when you need to unsubscribe multiple handlers at once. For example this el.unsubscribe(".mywidget") will remove all handlers with mywidget namespace.

     The selector is an optional parameter – CSS selector of child element. When provided allows containers to subscribe to events coming from particular children.

     The handler can be any function(evt:Event) {...} – callback that gets invoked when the event occurs. this variable is set to the evt.target – element that originated the event.

     To subscribe on event in EVENT_SINKING phase prepend the event name by ~ symbol. For example this handler
     container.subscribe("~keydown", function() {...});
     will receive the keydown event before its children.

     Note: this method mimics jQuery’s .on() method and has the same semantics.
     * @param {String} event
     * @param {String} selector
     * @param {(evt: Event) => boolean} handler
     * @returns {Element}
     */
    subscribe(event: String, selector?: String, handler?: (evt: Event) => boolean): Element;

    /**
     *Alias of subscribe(event: string [, selector: string] , handler: function) above.
     * @param {String} event
     * @param {String} selector
     * @param {(evt: Event) => boolean} handler
     * @returns {Element}
     */
    on(event: String, selector?: String, handler?: (evt: Event) => boolean): Element;

    /**
     *unsubscribe() method detaches event handler[s] from the element.
     * @param {(evt: Event) => boolean} handler
     * @returns {Element}
     */
    unsubscribe(handler: (evt: Event) => boolean): Element;

    /**
     *unsubscribe() method detaches event handler[s] from the element.
     * @param {Integer} eventGroup
     * @param {Integer} eventType
     * @returns {Element}
     */
    unsubscribe(eventGroup: Integer, eventType?: Integer): Element;

    /**
     *alias of unsubscribe methods above.
     * @param {(evt: Event) => boolean} handler
     * @returns {Element}
     */
    off(handler: (evt: Event) => boolean): Element;

    /**
     *alias of unsubscribe methods above.
     * @param {Integer} eventGroup
     * @param {Integer} eventType
     * @returns {Element}
     */
    off(eventGroup: Integer, eventType?: Integer): Element;

    /**
     *The method returns common parent element of this and other DOM elements.
     * @param {Element} other
     * @returns {Element}
     */
    commonParent(other: Element): Element;

    /**
     *The function returns list (array) of elements that were replaced in given row.
     * @param {Integer} rowNo
     * @returns {Element[]}
     */
    row(rowNo: Integer): Element[];

    /**
     *The function returns list (array) of elements that were replaced in given column.
     * @param {Integer} colNo
     * @returns {Element[]}
     */
    column(colNo: Integer): Element[];

    /**
     *The function returns position and height of the row.
     * @param {Integer} rowNo
     * @returns {MultipleReturnValue}
     */
    rowY(rowNo: Integer): MultipleReturnValue; //y: Integer, height: Integer;

    /**
     *The function returns position and width of the column.
     * @param {Integer} colNo
     * @returns {MultipleReturnValue}
     */
    columnX(colNo: Integer): MultipleReturnValue; // x: Integer, width: Integer;

    /**
     *The transact method executes so called editing transaction – group of operations that can undone/redone as a whole. The action function should have this signature:

     function action(transaction) { ... }
     Where the transaction is an instance of the Transaction interface – primitives used to modify state of the DOM. Any modification made through these function will be undone/redone properly when user will issue Undo/Redo commands in the editor.
     * @param {(transaction: Transaction) => void} action
     * @param {String} name
     * @returns {boolean}
     */
    transact(action: (transaction: Transaction) => void, name?: String): boolean;

    /**
     *
     The execCommand method executes undoable editing command. The command string identifies command to execute.

     Editing commands common to all editable elements ( <input|text>, <textarea>, <plaintext>, <htmlarea> ):

     "edit:cut" – cut selection – copy selection to the clipboard and remove it;
     "edit:copy" – copy selection to the clipboard;
     "edit:paste" – paste content of the clipboard;
     "edit:selectall" – select whole content of the element;
     "edit:undo" – undo last editing operation;
     "edit:redo" – redo last operation that was undone;
     "edit:delete-next" – if there is a selection – delete selected content, otherwise delete next character;
     "edit:delete-prev" – if there is a selection – delete selected content, otherwise delete previous character;
     "edit:delete-word-next" – if there is a selection – delete selected content, otherwise delete next word;
     "edit:delete-word-prev" – if there is a selection – delete selected content, otherwise delete previous word;
     "edit:insert-break" – essentially this is "ENTER" (VK_RETURN) command, actual DOM modification depends on context;
     "edit:insert-text" – inserts text at current caret position, attributes shall contain string to insert;
     Editing commands supported only by behavior:richtext elements ( <htmlarea> ):

     "edit:insert-soft-break" – "SHIFT+ENTER" command, inserts <br> separator but actual DOM modification depends on context;
     "format:apply-span:{tag-list}" – wrap selection into span element, if the selection contains one of tags they will be removed.
     {tag-list} is a pipe (|)  separated list of tag names. Example:
     execCommand("format:apply-span:b|strong") – will wrap selection into <b>...</b> while removing any other <b> and <strong> elements from the selection.
     Additional map parameter may contain list of DOM attributes to add to wrapping element, Example:
     execCommand("format:apply-span:font",{color:"#F00"}) – will wrap selection into <font color="#F00">...</font> element.
     "format:toggle-span:{tag-list}" – if selection contains one of the tags – removes them, otherwise it does "format:apply-span:..." action.
     "format:toggle-list:{list-tag}" – converts paragraphs in selection into a list. If selection is already a list of that type then items of the list will be converted tp simple paragraphs;
     {list-tag} can be either ul, ol or dl.
     "format:toggle-pre" – converts selection to or from <pre> block.
     "format:indent" –  wraps selected paragraphs into <blockquote> or sub-list.
     "format:unindent" –  unwraps selected paragraphs from <blockquote> or moves sub-list to one level up.
     "format:morph-block:{to-tag}" – changes tags of selected block elements. This way current <blockquote>  can be changed to <div> for example.
     * @param {String} command
     * @param {map} attributes
     * @returns {boolean}
     */
    execCommand(command: String, attributes?: map): boolean;

    /**
     *
     The queryCommand method reports state and allowance of particular command. The method accepts the same parameters as the execCommand(). Return value is an integer – combination of the following flags:

     0x01 – command is "on" state or "selected". For example, queryCommand("format:apply-span:b|strong") will return 0x01 value if selected text  contains either <b> or <strong> elements.
     0x02 – command is "disabled" or is not available in current context.
     * @param {String} command
     * @param {map} attributes
     * @returns {Integer}
     */
    queryCommand(command: String, attributes?: map): Integer;

    /**
     *Inserts the node in the DOM tree before this element.
     * @param {Node} node
     */
    insertNodeBefore(node: Node);

    /**
     *Inserts the node in the DOM tree after this element.
     * @param {Node} node
     */
    insertNodeAfter(node: Node);

    /**
     *Inserts the node after last node of this element so the node becomes last child node of the element.
     * @param {Node} node
     */
    appendNode(node: Node);

    /**
     *Inserts the node before first node of this element so the node becomes first child node of the element.
     * @param {Node} node
     */
    prependNode(node: Node);


}

declare const Event: StaticEvent;

interface StaticEvent {
    /** Mouse group */
    readonly MOUSE: Integer;
    /** Mouse/Pointer enters the element. */
    readonly MOUSE_ENTER: Integer;
    /** Mouse/Pointer leaves the element. */
    readonly MOUSE_LEAVE: Integer;
    /** Mouse/Pointer moves over the element. */
    readonly MOUSE_MOVE: Integer;
    /** One of mouse buttons pressed in the element. event.mainButton and event.propButton will tell what button was pressed. */
    readonly MOUSE_DOWN: Integer;
    /** One of mouse buttons released in the element. event.mainButton and event.propButton will tell what button was pressed.
     To detect single MOUSE CLICK event use following condition:
     event.type == Event.MOUSE_UP && this.getState(Element.STATE_PRESSED) */
    readonly MOUSE_UP: Integer;
    /** Double mouse click in the element. */
    readonly MOUSE_DCLICK: Integer;
    /** Mouse wheel rotation. event.wheelDelta is a number of wheel ticks made. */
    readonly MOUSE_WHEEL: Integer;
    /** Repeatable event that is generated when one of mouse button pressed. */
    readonly MOUSE_TICK: Integer;
    /** Pulsed event, is generated when mouse is not moving some short period of time. If it is not handled in the code then it is used by the engine to popup tooltip for the element. */
    readonly MOUSE_IDLE: Integer;
    /** mouse pressed and moved by distance larger than some threshold.  <input|text> and <textarea> start dragging selection while handling the event. To discard default handlers – consume the event by returning true. */
    readonly MOUSE_DRAG_REQUEST: Integer;
    /** Key group */
    readonly KEY: Integer;
    /** Keyboard key pressed. event.keyCode is virtual key code of the key. */
    readonly KEY_DOWN: Integer;
    /** Keyboard key released. event.keyCode is virtual key code of the key */
    readonly KEY_UP: Integer;
    /** Character key pressed. event.keyCode is a value of UNICODE codepoint. */
    readonly KEY_CHAR: Integer;
    /** focus group */
    readonly FOCUS: Integer;
    /** Focusable element got input focus. */
    readonly GOT_FOCUS: Integer;
    /** Elements lost input focus. */
    readonly LOST_FOCUS: Integer;
    /** behaviour group */
    readonly BEHAVIOR_EVENT: Integer;
    /** Click on button, generated by behaviors: button, checkbox, radio. */
    readonly BUTTON_CLICK: Integer;
    /** Mouse/Key pressed in button, generated by behaviors: button, checkbox, radio. */
    readonly BUTTON_PRESS: Integer;
    /** State (value) of button was changed, generated by behaviors: checkbox, radio. */
    readonly BUTTON_STATE_CHANGED: Integer;
    /** Value of editbox is about to be changed, generated by behaviors: edit, number, decimal, date, masked. element.value reflects old value. */
    readonly EDIT_VALUE_CHANGING: Integer;
    /** Value of editbox was just changed, generated by behaviors: edit, number, decimal, date, masked. element.value reflects new value. */
    readonly EDIT_VALUE_CHANGED: Integer;
    /** Selection was changed in elements-selectors. generated by behaviors: select, dropdown-select, calendar. */
    readonly SELECT_SELECTION_CHANGED: Integer;
    /** State of item was changed in elements-selectors. generated by behaviors: select when some of the <options> are expanded/collapsed, event.target is the item that changed its state. behavior: calendar sends this event after calendar was switched to show another month so by handling this event you can update DOM inside the calendar. */
    readonly SELECT_STATE_CHANGED: Integer;
    /** Click on hyperlink. event.target is that hyperlink element. */
    readonly HYPERLINK_CLICK: Integer;
    /** Request to container to activate child. accesskey processor post this message if accesskey is defined for the element but element is passive, e.g. tab on Tabs control. See: extenders.js / type Tabs. */
    readonly ACTIVATE_CHILD: Integer;
    /** Request to show popup just received. event.source is the popup element. The popup can be populated at this moment. */
    readonly POPUP_REQUEST: Integer;
    /** Popup element is ready to be shown. */
    readonly POPUP_READY: Integer;
    /** Popup became invisible. */
    readonly POPUP_DISMISSED: Integer;
    /** Happens when menu item is highlighted. */
    readonly MENU_ITEM_ACTIVE: Integer;
    /** Click on menu item. event.target is the item event.owner is an owner of the popup menu. */
    readonly MENU_ITEM_CLICK: Integer;
    /** Is sent by the engine when context menu needs to be shown. evt.target is a top element that have got e.g. right mous click. evt.source [read/write] is a menu element that is about to popup. You can set your own menu element to the evt.source field while handling this event. */
    readonly CONTEXT_MENU_REQUEST: Integer;
    /** Is sent by the engine when context menu is found. evt.source is the menu element that you can modify at this point. */
    readonly CONTEXT_MENU_SETUP: Integer;
    /** Notification that the element changed its visibility either by changing display or visibility CSS attributes. The event is sent only to the element itself (so not a bubbling event). */
    readonly VISUAL_STATUS_CHANGED: Integer;
    /** Notification that the element or one of its containers have changed its disabled status. */
    readonly DISABLED_STATUS_CHANGED: Integer;
    /** Request for tooltip, the event is sent in response of MOUSE_IDLE. Element on evt.source is a proposed tooltip element. You can assign your own DOM element to the evt.source field or text to evt.data field. To cancel tooltip generation set evt.source to null and return true (event handled) from the event handler. */
    readonly TOOLTIP_REQUEST: Integer;
    /** Notification that document finishes its loading – all requests for external resources are finished. evt.target is the root node ( <html> ) of the document that is complete. Note that the event is being generated even some of resources were not available. DOM elements that contain non-available resources will get :incomplete state flag. */
    readonly DOCUMENT_COMPLETE: Integer;
    /** behavior:form detected submission event from button type=reset. evt.data field contains data to be sent to the server as a map (object). You can modify the data or discard submission by returning true ("event consumed") from the event handler. */
    readonly FORM_SUBMIT: Integer;
    /** behavior:form detected reset event (from button type=reset). evt.data field contains data to be set to input fields. */
    readonly FORM_RESET: Integer;
    /** Execute command: event.command:string is a command to be executed,  event.data – parameters. */
    readonly COMMAND_EXEC: Integer;
    /** Query state/allowance of command execution. */
    readonly COMMAND_QUERY: Integer;
    /** scroll group */
    readonly SCROLL: Integer;
    /** Requests to scroll, typically are coming from <input type=vscrollbar> or <input type=hscrollbar>.
     In case of SCROLL_POS use event.scrollPos field to get requested position to scroll. */
    readonly SCROLL_HOME: Integer;
    /**  */
    readonly SCROLL_END: Integer;
    /**  */
    readonly SCROLL_STEP_PLUS: Integer;
    /**  */
    readonly SCROLL_STEP_MINUS: Integer;
    /**  */
    readonly SCROLL_PAGE_PLUS: Integer;
    /**  */
    readonly SCROLL_PAGE_MINUS: Integer;
    /**  */
    readonly SCROLL_POS: Integer;
    /**  */
    readonly GESTURE_REQUEST: Integer;
    /** The zoom gesture. Event.deltaV  field contains float > 1.0 in case of zoom-out and float < 1.0 for zoom-in. */
    readonly GESTURE_ZOOM: Integer;
    /** The pan/swipe gesture. Event.deltaX and Event.deltaY fields contain integers – number of pixels in X and Y directions. */
    readonly GESTURE_PAN: Integer;
    /** The rotation gesture. Event.deltaV  field contains delta angle (in radians). */
    readonly GESTURE_ROTATE: Integer;
    /** The press and tap gesture. */
    readonly GESTURE_TAP1: Integer;
    /** Tap by two fingers gesture. */
    readonly GESTURE_TAP2: Integer;
    /**  */
    readonly GESTURE_FLAG_ZOOM: Integer;
    /**  */
    readonly GESTURE_FLAG_ROTATE: Integer;
    /**  */
    readonly GESTURE_FLAG_PAN_VERTICAL: Integer;
    /**  */
    readonly GESTURE_FLAG_PAN_HORIZONTAL: Integer;
    /**  */
    readonly GESTURE_FLAG_TAP1: Integer;
    /**  */
    readonly GESTURE_FLAG_TAP2: Integer;
    /**  */
    readonly GESTURE_FLAG_PAN_WITH_GUTTER: Integer;
    /**  */
    readonly GESTURE_FLAG_PAN_WITH_INERTIA: Integer;
    /**  */
    readonly GESTURE_FLAGS_ALL: Integer;
    /** Event dispatching direction. If this flag set then event is being dispatched in the direction from parent to child. Example:
     switch(evt.type)
     {
        case Event.MOUSE_DOWN | Event.SINKING:
             // handle thr event before any child
        case Event.MOUSE_DOWN:
             // it is here as no one child processed it.
     } */
    readonly SINKING: Integer;
    /**
     Event was handled (event handler function returned true) by some child of the element or behavior. Example:
     switch(evt.type)
     {
        case Event.MOUSE_DOWN:
            // after all children and no one has handled it.
        case Event.MOUSE_DOWN | Event.HANDLED:
            // after all children, and some child has handled it.
     } */
    readonly HANDLED: Integer;
    /** Values of the draggingMode attribute below */
    readonly DRAGGING_MOVE: Integer;
    /** Values of the draggingMode attribute below */
    readonly DRAGGING_COPY: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_CANCEL: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_BACK: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_TAB: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_CLEAR: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_RETURN: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_SHIFT: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_CONTROL: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_MENU: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_PAUSE: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_CAPITAL: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_KANA: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_HANGUL: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_JUNJA: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_FINAL: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_HANJA: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_KANJI: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_ESCAPE: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_CONVERT: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_SPACE: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_PRIOR: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_NEXT: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_END: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_HOME: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_LEFT: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_UP: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_RIGHT: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_DOWN: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_SELECT: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_PRINT: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_EXECUTE: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_SNAPSHOT: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_INSERT: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_DELETE: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_HELP: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_SLEEP: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_NUMPAD0: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_NUMPAD1: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_NUMPAD2: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_NUMPAD3: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_NUMPAD4: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_NUMPAD5: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_NUMPAD6: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_NUMPAD7: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_NUMPAD8: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_NUMPAD9: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_MULTIPLY: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_ADD: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_SEPARATOR: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_SUBTRACT: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_DECIMAL: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_DIVIDE: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_F1: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_F2: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_F3: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_F4: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_F5: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_F6: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_F7: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_F8: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_F9: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_F10: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_F11: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_F12: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_F13: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_F14: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_F15: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_F16: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_F17: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_F18: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_F19: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_F20: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_F21: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_F22: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_F23: Integer;
    /** ctrl(mac) / win(win) + key */
    readonly VK_F24: Integer;
    /** size group */
    readonly SIZE: Integer;

}

declare const evt: Event;

interface Event extends StaticEvent {
    /** type of the event, value equal to one of the constant above. */
    readonly type: Integer;
    /** true if ALT key is pressed. Valid for Mouse, Key events. */
    readonly altKey: boolean;
    /** true if CTRL key is pressed. Valid for Mouse, Key events. */
    readonly ctrlKey: boolean;
    /** true if SHIFT key is pressed. Valid for Mouse, Key events. */
    readonly shiftKey: boolean;
    /** true if either CTRL (on Windows) or COMMAND (on OSX) keys are pressed. Valid for Mouse and Key events. Use it if you want to handle keyboard shortcut commands in cross-platform manner. CTRL+C on Windows is an equivalent of COMMAND+C on OSX. Bastards, aren’t they? */
    readonly shortcutKey: boolean;
    /** true if either "Win" (on Windows keyboard) or COMMAND (on Mac keyboard) keys are pressed. Valid for Mouse and Key events. */
    readonly commandKey: boolean;
    /** indicates whether the key is an extended key, such as the right-hand ALT and CTRL keys that appear on an enhanced 101- or 102-key keyboard. */
    readonly extendedKey: boolean;
    /** true if main mouse button pressed (usually left mouse button). Valid for Mouse events. */
    readonly mainButton: boolean;
    /** true if property mouse button pressed (usually right mouse button). Valid for Mouse events. */
    readonly propButton: boolean;
    /** bit flags representing pressed mouse buttons, 0x01 – main (usually left) mouse button, 0x02 – right mouse button, 0x04 – middle mouse button. */
    readonly buttons: Integer;
    /** element this event tageted to. */
    readonly target: Element;
    /** reason field of control event code. */
    reason: Integer;
    /** key scan code for KEY_DOWN/KEY_UP events and unicode codepoint of the character pressed for the KEY_CHAR event. */
    readonly keyCode: Integer;
    /** event group symbol, here it is a symbol of event handler function: #onMouse, #onKey, #onFocus, etc. */
    readonly group: Symbol;
    /** mouse wheel "tick" – valid in onMouse/MOUSE_WHEEL event. Either -1 or +1 depending on direction. */
    readonly wheelDelta: Integer;
    /** scroll position in SCROLL_POS event. */
    readonly scrollPos: Integer;
    /** #vertical | #horizontal, scrollbar axis in scroll events. */
    readonly acrollAxis: Symbol;
    /**  x coordinate of the mouse event relative to the element itself (origin of its content box) */
    readonly x: Integer;
    /** y coordinate of the mouse event relative to the element itself (origin of its content box) */
    readonly y: Integer;
    /** x coordinate of the mouse event relative to the element’s root element (<html>). */
    readonly xRoot: Integer;
    /** y coordinate of the mouse event relative to the element’s root element (<html>). */
    readonly yRoot: Integer;
    /** x coordinate of the mouse event relative to the element’s view (window). */
    readonly xView: Integer;
    /** y coordinate of the mouse event relative to the element’s view (window). */
    readonly yView: Integer;
    /** x coordinate of the mouse event relative to the screen. */
    readonly xScreen: Integer;
    /** y coordinate of the mouse event relative to the screen. */
    readonly yScreen: Integer;
    /** owner (initiator) of the menu in MENU_ITEM_CLICK, also this is value of last parameter in Element.sendEvent method. */
    owner: Element;
    /** onMouse(evt) only. true if mouse is on icon area. Element icon is foreground, no-repeat image. */
    readonly isOnIcon: boolean;
    /** onMouse(evt) and onExchange(evt) only. Reference of element being dragged when onMouse and data being dragged when onExchange(). */
    dragging: Element;
    /** onMouse(evt) only. Dragging mode – either Event.DRAGGING_MOVE or Event.DRAGGING_COPY – current dragging mode. */
    draggingMode: Integer;
    /** onExchange(evt) only. One of the following values:
     #text – plain text;
     #html – html;
     #url – hyperlink;
     #file – file list;
     #json – JSON data (sciter specific); */
    readonly draggingDataType: Symbol;
    /** onGesture() event specific fields. See prose above about GESTURE_**** values. */
    readonly deltaV: Integer;
    /** onGesture() event specific fields. See prose above about GESTURE_**** values. */
    readonly deltaX: Integer;
    /** onGesture() event specific fields. See prose above about GESTURE_**** values. */
    readonly deltaY: Integer;
    /** onGesture() event specific fields. See prose above about GESTURE_**** values. */
    readonly flags: Integer;
    /** onMouse(evt) only. Set current cursor. */
    cursor: String;

    /**
     * Returns true if the event has symbolic name of eventName and its target matches the selector. The eventName can accept following symbolic names: https://sciter.com/docs/content/sciter/Event.htm#symbolic-event-names
     * @param {String} eventName
     * @param {String} selector
     * @returns {boolean}
     */
    match(eventName: String ,selector?: String): boolean;

    /**
     * Retuns list of data items types associated with exchange oeration. The list is an array containing #text, #html, #url, #file, #picture or #json.
     * @returns {Symbol[]}
     */
    exchangeData(): Symbol[];

    /**
     * The method allows to get data of particular data type:

     #text – returns string – dragged text;

     #html – returns (url,html) pair – url of dragged HTML fragment and the HTML itself;

     #url – returns (caption,url) pair – caption and the url itself;

     #file – returns filenames array – list of dragged file paths;

     #picture – returns Image object if dragged data contains an image;

     #json – returns value – json value.
     * @param {Symbol} dataType
     * @returns {any}
     */
    exchangeData(dataType: Symbol): any;
}

/**
 * bookmark object that is a tuple (of length 3) having tag #bookmark. Usually you will get ready to use bookmarks from various properties or  methods but if needed bookmarks can be constructed literally as:

 var bm = [bookmark: node, index, after];
 Where:

 node – Element or Node object.
 index – index of the position inside the node. В for Element it is nodeIndex of its child node and for Nodes it is character index.
 after – true | false, if true then this bookmark marks "past edge" of the entity marked by node/index pair.
 */
interface Bookmark {
    bookmark: Node;

    [i: number]: any;
}

interface Behavior {

}

interface Extenders {

}

interface Attributes {
    /** number of attributes of the element. Read-only property. */
    readonly length: Integer;

    /** value of attribute at the index position. Index here is either string (name of attribute) or integer (zero-based index of the attribute). Read-write index accessor. */
    [key: string]: any;

    /**
     * Returns string – name of the attribute at index position. Index is zero-based integer value here.
     * @param index
     * @returns {String}
     */
    name(index): String;

    /**
     * Clears collection of attributes of the element.
     */
    clear(): void;

    /**
     * Removes attribute from the collection of attributes. Attr here is either string (name of attribute) or integer (zero-based index of the attribute).
     * @param attr
     */
    remove(attr): void;

    /**
     * Returns true if attr exists in the collection of attributes. Attr here is either string (name of attribute) or integer (zero-based index of the attribute).
     * @param attr
     * @returns {boolean}
     */
    exists(attr): boolean;

    /**
     * Adds class name[s] to the class attribute of the element.
     * @param {String} className
     */
    addClass(...className: String[]);

    /**
     * Removes class name[s] from the class attribute of the element.
     * @param {String} className1
     */
    removeClass(...className1: String[]);

    /**
     * Adds or removes class. If on is provided then adds the class if it is true and removes it if on is false. If no on provided removes class if it is not there, or adds it otherwise.
     * @param {String} className
     * @param {boolean} on
     */
    toggleClass(className: String, on?: boolean);

    /**
     * Returns true if the element has className defined.
     * @param {String} className
     * @returns {boolean}
     */
    hasClass(className: String): boolean;
}

interface Style {
    /** value of style attribute attname (CSS). В attname here is a string or a symbol. Read-write index accessor.
     See list of supported names of CSS attributes.

     To clear value of style attribute assign undefined value to it:

     el.style#background-color = undefined; */
    [key: string]: String | Symbol;

    /** background image if it is defined in CSS. */
    backgroundImage: Image;
    /** foreground image if it is defined in CSS or behaviors. For the <video> element, for example, it will return image representing current frame.  */
    foregroundImage: Image;
    /** width in pixels of background image if it is available or undefined if background image is available. */
    backgroundImageWidth: Integer;
    /** height in pixels of background image if it is available or undefined if background image is available. */
    backgroundImageHeight: Integer;
    /** width in pixels of foreground image if it is available or undefined if foreground image is available. */
    foregroundImageWidth: Integer;
    /** height in pixels of foreground image if it is available or undefined if foreground image is available. */
    foregroundImageHeight: Integer;

    /**
     *
     Clears all attributes previously set by using [attname] accessor for the element or the set() function.

     Returns the style object itself allowing to chain the call with the set()
     * @returns {Style}
     */
    clear(): Style;

    /**
     * Sets or clears multiple style attributes on the element. As function accepts single object pareameter then it can be used with "object-call" notation:

     el.style.set {
   display: "block",
   width: px(40),
   height: px(20)
};
     * @param {Object} attributes
     * @returns {Style}
     */
    set(attributes: Object): Style;

    /**
     * Creates and sets cursor from img and hotspotX/Y coordinates. To reset cursor to its default value use el.style.cursor(null);
     * @param {Image | null} img
     * @param {integer} hotspotX
     * @param {integer} hotspotY
     * @returns {Style}
     */
    cursor(img: Image | null, hotspotX?: integer, hotspotY?: integer): Style;

    /**
     *
     Returns array of style rules applied to the element. Each element of the array is an object of following types:

     { type: #style-rule, selector: <string>, file: <string>, lineNo: integer; } – for the rule defined in CSS;
     { type: #inline-style, text: <string> } – for styles defined by the style="…" attribute in the DOM;
     { type: #runtime-style } – designates that the element has styles set in runtime through script.
     * @returns {Array}
     */
    rules(): Array;

    /**
     * Gathers all style defined style attributes and returns them as an object.
     * @returns {Object}
     */
    all(): Object;

    /**
     *
     Returns value of CSS constant defined in CSS. It could be single value for the case (CSS):

     @const SINGLE: #ff007f;

     or array for the case like:

     @const MULTY: 12px 14px;
     * @param {String | Symbol} name
     * @returns {value | array}
     */
    constant(name: String | Symbol): value | array;

    /**
     *
     The dimension method is an equivalent of setting these two style attributes:

     elem.style.width = ... ;
     elem.style.height = ... ;
     The only difference is when last parameter delayed = true is provided. With it the method changes dimensions of the element immediately and defers remeasurement of children for some later time. It makes sense to use this method if you need to update dimensions of the overflow:auto | scroll element with many children in response of some frequent events like MOUSE_MOVE (E.g. in custom splitter implementation). In this case mutiple MOUSE_MOVEs will end up in only one remeasurement of element’s content.
     * @param {length | int | undefined} width
     * @param {length | int | undefined} height
     * @param {false | true} delayed
     */
    dimension(width: length | int | undefined, height: length | int | undefined, delayed?: false | true);

    /**
     * Enumerates CSS rules defined and used by the document. Returns number of rules processed.

     Where:

     callback is function( selector, file, lineNo, usageCounter ) that receives CSS selector , file URL, line number where the rule is defined and the number of DOM elements that use this rule to the moment of the documentRules() call.
     filter is an object that defines enumeration filter and CSS properties accessor callback. The filter object accepts the following optional fields:
     selector – string, if defined then the callback will receive only rules having that selector;
     file – string, url of CSS file where the rule is defined;
     lineNo – integer, line number in CSS file where the rule is defined;
     properties – function(props:object) : null | object , properties accessor function, the function will receive CSS properties defined by the rule. If the function returns an object then properties of the CSS rule will be updated by the object properties.
     Therefore the documentRules function can be used as for inspection as for mutation of the CSS rules table associated with the document.
     * @param {(selector: String, file: String, lineNo: Integer, usageCounter: Integer) => void} callback
     * @param {Object} filter
     * @returns {integer}
     */
    documentRules(callback?: (selector: String, file: String, lineNo: Integer, usageCounter: Integer) => void, filter?: Object): integer;

    /**
     * The method gets or sets (if varToSet provided) single CSS variable defined on the element.
     * @param {String} varName
     * @param {value} varToSet
     * @returns {value | undefined}
     */
    variable(varName: String, varToSet?: value): value | undefined;

    /**
     * The method gets or sets (if varsToSet provided) CSS variables defined on the element.
     * @param {Object} varsToSet
     * @returns {Object | undefined}
     */
    variables(varsToSet?: Object): Object | undefined;
}

interface States {
    /** true if this element is a link – has href attribute defined. */
    link: boolean;
    /**  */
    hover: boolean;
    /**  */
    active: boolean;
    /** this element is in focus. To set focus on the element is it enough to assign true value to the attribute:
     el.state.focus = true; */
    focus: boolean;
    /** this element is in focus and got the focus due to TAB/SHIFT+TAB key handling. */
    readonly tabfocus: boolean;
    /**  */
    visited: boolean;
    /**  */
    current: boolean;
    /**  */
    checked: boolean;
    /**  */
    disabled: boolean;
    /**  */
    readonly: boolean;
    /**  */
    expanded: boolean;
    /**  */
    collapsed: boolean;
    /**  */
    incomplete: boolean;
    /** element is running animation. */
    readonly animating: boolean;
    /** element is focusable. Focusable is the element having either: tabindex >= 0 attribute defined or it has behavior that has focus handler defined. */
    focusable: boolean;
    /** element is an anchor (first element) in selection. */
    anchor: boolean;
    /** element was synthesized – created by some behavior. */
    synthetic: boolean;
    /** element is shown as popup window. To close such popup window simply assign value false to the attribute:
     el.state.popup = false; */
    popup: boolean;
    /** element is requested popup to be shown and that popup is visible. Following:
     el.popup(elementToPopup, pos);
     will cause this flag to be set for the element el. */
    readonly ownspopup: boolean;
    /** the element is empty – has no children and no text. */
    readonly empty: boolean;
    /** element is requested data to be delivered by calling el.request(...) and that data is not delivered yet. */
    busy: boolean;
    /** the dragged element is over the element. */
    readonly dragover: boolean;
    /** dragging is active and the element is active drop target for the dragging element. */
    readonly droptarget: boolean;
    /** either one of these is true for the element that is being dragged. Engine creates copy of drag-source element and that copy is being dragged. */
    readonly moving: boolean;
    /** either one of these is true for the element that is being dragged. Engine creates copy of drag-source element and that copy is being dragged. */
    readonly copying: boolean;
    /** element one of these is true for the element that being dragged. */
    readonly dragsource: boolean;
    /** element has mouse pressed in it. */
    pressed: boolean;
    /** element is in directional environment – itself or one of its parents has attribute dir defined. */
    readonly isltr: boolean;
    /** element is in directional environment – itself or one of its parents has attribute dir defined. */
    readonly isrtl: boolean;
    /** "raw" value of the element. It is either the value managed by native behavior or, if the element has no behavior attached, it is a text of the element (see Element.text). */
    value: String;
    /** number of screen (monitor) on which this element is rendered at the moment. Note in can be different from view.screen for popup elements. */
    readonly screen: Integer;
    /** flag indicating that the element is awaiting to be drawn after Element.refresh() was issued for it. Sciter sets this flag autmatically. It also resets it when the element gets drawn on the scree. In between you can set/reset it from code. */
    awaitsDraw: boolean;
    /** reports flow type used by the element, is one of:
     #vertical, #horizontal, #horizontal-flow, #vertical-flow, #grid, #table, #table-fixed, #stack, #text, #table-row, #table-body, #columns, #null, #image, #svg, #svg-child or undefined (if element is inline or display-none). */
    readonly flowType: Symbol;

    /**
     * Returns integer – "ORed" set of Element.STATE_*** constants.
     * @returns {Integer}
     */
    get(): Integer;

    /**
     * Sets flags. flags here "ORed" set of Element.STATE_*** constants.
     * @param {Integer} flags
     * @returns {undefined}
     */
    set(flags: Integer): undefined;

    /**
     * Clears flags.
     * @param {Integer} flags
     * @returns {undefined}
     */
    clear(flags: Integer): undefined;
}

interface Selection {
    /** Reports type of the selection: #text, #cells, #blocks. */
    readonly type: null | Symbol;
    /** true if the selection is represented by only caret so selection.start == selection.end. */
    readonly isCollapsed: boolean;
    /** DOM position of selection anchor. */
    readonly anchor: null | Bookmark;
    /** DOM position of selection caret. */
    readonly caret: null | Bookmark;
    /** DOM position of either caret or anchor, whichever is lower in DOM order. */
    readonly start: null | Bookmark;
    /** DOM position of either caret or anchor, whichever is greater in DOM order. */
    readonly end: null | Bookmark;
    /**  text contained in the selection. */
    readonly text: String;
    /** selected html fragment. */
    readonly html: String;

    /**
     * Collapse selection range to single caret position. towhat is one of: #toCaret, #toAnchor,#toStart or #toEnd
     * @param {Symbol} towhat
     * @returns {Bookmark}
     */
    collapse(towhat: Symbol): Bookmark;

    /**
     * Set’s selection to the range or single caret position.
     * @param {Bookmark} caret
     * @param {Bookmark} anchor
     * @returns {boolean}
     */
    select(caret: Bookmark, anchor?: Bookmark): boolean;

    /**
     * Set’s selection to either the element el itself (what is #element) or to its content – its first and last caret positions.
     * @param {element} el
     * @param {Symbol} how
     * @returns {boolean}
     */
    select(el: element, how?: Symbol): boolean;

    /**
     *
     Advances target to new position by step. The target defines what end of selection to advance, can be one of:

     #both – default, caret and anchor is moved to new position, collapses the selection;
     #caret – caret position, changes the selection;
     #anchor – anchor position, changes the selection;
     #start – start position (either anchor or caret), changes the selection;
     #end – end position (either anchor or caret), changes the selection
     The step is one of:

     #next – next caret position;
     #prior – previous caret position;
     #wordStart – start of the word;
     #wordEnd – end of the word;
     #lineStart – start of the line;
     #lineEnd – end of the line;
     #first – first caret position of the element having the selection;
     #last – last caret position of the element having the selection.
     * @param {Symbol} step
     * @param {Symbol} target
     * @returns {boolean}
     */
    advance(step: Symbol, target?: Symbol): boolean;

    /**
     *
     marks region of text from start to end by mark name that can be styled in CSS by ::mark(markName) { ... } selector/rule.

     The function returns number of changes made.
     * @param {Bookmark} start
     * @param {Bookmark} end
     * @param {String} markName
     * @returns {Integer}
     */
    applyMark(start: Bookmark, end: Bookmark, markName: String): Integer;

    /**
     *
     clears mentioned mark from the region.

     The function returns number of changes made.
     * @param {Bookmark} start
     * @param {Bookmark} end
     * @param {String} markName
     * @returns {Integer}
     */
    clearMark(start: Bookmark, end: Bookmark, markName: String): Integer;

    /**
     *
     Returns view relative coordinates of:

     part – one of symbolic constants #left, #top, #right, #bottom, #width or #height. Defines part of box (rectangle) to return.

     If part is #rect then the function returns four values – left, top, right, bottom. Use it for example as
     var (x1,y1,x2,y2) = this.box(#rect);
     If part is #rectw then the function returns four values – left, top, width and height. Use it for example as
     var (x,y,w,h) = this.box(#rectw);
     If part is #dimension the function returns two values – width and height. Use it as:
     var (w,h) = this.box(#dimension);
     If part is #position the function returns two values – left and top. Use it as:
     var (x,y) = this.box(#position);
     * @param {Symbol} part
     */
    box(part: Symbol);
}

interface Transaction {
    /**
     * Add or remove elements attribute by name. To remove attribute use undefined value.
     * @param {Element} element
     * @param {String} name
     * @param {String | undefined} value
     * @returns {Transaction}
     */
    attr(element: Element, name: String, value: undefined | String): Transaction;

    /**
     * Changes text of the element or text node.
     * @param {Element | Node} element
     * @param {String} newText
     * @returns {Transaction}
     */
    text(element: Element | Node, newText: String): Transaction;

    /**
     * Change tag of the element. For example in some cases you may want to change <p> to <li> without recreating the element.
     * @param {Element} element
     * @param {String} tag
     * @returns {Transaction}
     */
    tag(element: Element, tag: String): Transaction;

    /**
     *
     Split DOM elements at pos position until the element. Example, for the markup:

     <p id=test>123<b>456</b>789</p>
     This code:

     var p = $(p#test);
     var b = p.$(b);
     var pos = [bookmark: b.nodes()[0], 1, false]; // start edge of character '5' in first text node of the <b> element.
     transact.split( pos, p );
     will change the DOM to this state:

     <p id=test>123<b>4</b><b>56</b>789</p>
     The function returns bookmark set to position inside until element.
     * @param {Bookmark} pos
     * @param {Element} until
     * @returns {Bookmark}
     */
    split(pos: Bookmark, until: Element): Bookmark;

    /**
     *
     Wraps from..to range into the element.

     Returns two bookmarks – start and end of content range that was wrapped.
     * @param {Bookmark} from
     * @param {Bookmark} to
     * @param {Element} into
     * @returns {Transaction}
     */
    wrap(from: Bookmark, to: Bookmark, into: Element): Transaction;

    /**
     *
     Moves content of the element into its parent (P), removes the element.

     Returns two bookmarks – start and end of content range that was merged into P element.
     * @param {Element} el
     * @returns {MultipleReturnValue}
     */
    unwrap(el: Element): MultipleReturnValue; //[Bookmark,Bookmark];

    /**
     * TBD (insert Node or Element at index position inside the el).
     * @param {Node} node
     * @param {Element} el
     * @param {Index} at
     * @param {true} after
     * @returns {Transaction}
     */
    insertNode(node: Node, el: Element, at: Index, after?: true): Transaction;

    /**
     * TBD (remove Node or Element from the DOM).
     * @param {Node} node
     * @returns {Transaction}
     */
    removeNode(node: Node): Transaction;

    /**
     * Inserts HTML fragment at the position. Returns array of inserted [top level] nodes.
     * @param {Bookmark} at
     * @param {String} html
     * @returns {Node[]}
     */
    insertHtml(at: Bookmark, html: String): Node[];

    /**
     * Inserts text at the position. Returns bookmark of last character inserted.
     * @param {Bookmark} at
     * @param {String} text
     * @returns {Bookmark}
     */
    insertText(at: Bookmark, text: String): Bookmark;

    /**
     * TBD (removes range from the DOM).
     * @param {Bookmark} from
     * @param {Bookmark} to
     * @returns {Transaction}
     */
    removeRange(from: Bookmark, to: Bookmark): Transaction;

}

interface Graphics {

}

declare const Node: StaticNode;

interface StaticNode {
    /**
     * Static constructor of text DOM nodes.
     * @param {String} text
     * @returns {Node}
     */
    createText(text: String): Node;

    /**
     * Static constructor of comment DOM nodes.
     * @param {String} text
     * @returns {Node}
     */
    createComment(text: String): Node;

    /**
     * Static constructor of Element [node]. Equivalent of new Element(...).
     * @param {Symbol | String} tagname
     * @param {Object} attributes
     * @param {String} text
     * @returns {Element}
     */
    createElement(tagname: Symbol | String, attributes?: Object, text?: String): Element;
}

interface Node extends StaticNode {
    /** parent element of the node or null if this node is not connected to any element */
    readonly parent: Element;
    /** index of the node in parent nodes collection. */
    readonly nodeIndex: Integer;
    /** next sibling node of the node or null if this is the last element in parent collection. */
    readonly nextNode: Element | Node;
    /** previous sibling node of the node or null if this is the first node in parent collection. */
    readonly priorNode: Element | Node;
    /** text of the node */
    text: String;
    /** true if this node is an element, false – otherwise. */
    readonly isElement: boolean;
    /** true if the node is a text node. */
    readonly isText: boolean;
    /** true if the node is a comment node. */
    readonly isComment: boolean;

    /**
     * Returns string – text representation of the node.
     * @returns {String}
     */
    toString(): String;

    /**
     * Returns new copy of the node. New node is disconnected from the DOM.
     * @returns {Node}
     */
    clone(): Node;

    /**
     * Inserts the node in the DOM tree before this element.
     * @param {Node} node
     */
    insertNodeBefore(node: Node): void;

    /**
     * Inserts the node in the DOM tree after this element.
     * @param {Node} node
     */
    insertNodeAfter(node: Node): void;

    /**
     * Removes this node from its parent’s nodes collection. After the call of this method this.parent will become null.
     * @returns {Node}
     */
    detach(): Node;

    /**
     * Removes this node from its parent’s nodes collection. After the call of this method this.parent will become null.
     * @returns {Element}
     */
    remove(): Element;

    /**
     * Returns common parent of this and other node – nearest element to which these both nodes belong to.
     * @param {Node} other
     * @returns {Element}
     */
    commonParent(other: Node): Element;
}

declare const View: StaticView;

interface StaticView {
    readonly WINDOW_MINIMIZED: Integer;
    readonly WINDOW_MAXIMIZED: Integer;
    readonly WINDOW_HIDDEN: Integer;
    readonly WINDOW_SHOWN: Integer;
    readonly WINDOW_FULL_SCREEN: Integer;
}

declare const view: View;

interface View extends StaticView {
    /** root element of a document loaded into the view. */
    root: Element;
    /** state of the window. Applicable only for top-level windows. Accepts values: View.WINDOW_MINIMIZED, View.WINDOW_MAXIMIZED, View.WINDOW_HIDDEN, View.WINDOW_SHOWN or View.WINDOW_FULL_SCREEN. */
    readonly windowsState: Integer;
    /** current element that has input focus. To set new element in focus use view.focus = el; */
    focus: Element;
    /** "events root" element. Used for implementation of "modal document loops". If set then all UI events that are targeted to elements that are not descendants of the element will be rerouted to the element. Setting this element may cause current focus element to be changed. Here is typical modal document loop:
     view.eventsRoot = dlg;
     while (dlg.isVisible) view.doEvent();
     dlg.style#display = "none";
     view.eventsRoot = null; */
    eventsRoot: Element;
    /** screen number where this window is located */
    readonly screen: Integer;
    /** number of screens (monitors) in the system. */
    readonly screens: Integer;
    /** window caption. */
    windowCaption: String;
    /** aspect area of client area of this window; */
    windowAspectRatio: Float | null;
    /** true if window can be resized by the user; */
    windowResizable: boolean;
    /** true if window has minimize button – can be minimized by the user; */
    windowMinimizable: boolean;
    /** true if window has maximize button – can be maximized by the user; */
    windowMaximizable: boolean;
    /** true if the window is at the topmost level; */
    windowTopmost: boolean;
    /** (x:integer,y:integer), min window dimension constraints. User cannot make window smaller than these;
     Example: view.minSize = (160,100); */
    windowMinSize: MultipleReturnValue; // x: Integer, y: Integer
    /** (x:integer,y:integer), max window dimension constraints. User cannot make window larger than these;
     Example: view.maxSize = (1600,1000); */
    windowMaxSize: MultipleReturnValue; // x: Integer, y: Integer
    /** window icon, the property accepts: null – set default icon, "url" – string, url of window icon or instance of Image. */
    windowIcon: null | String;
    /** window blur-behind effect, the property accepts: #auto | #ultra-dark | #dark | #light | #ultra-light | #none values. If this flag is set then the window window is semitransparent. Root document shall use html { background:transparent; } in order to see desktop behind the window. */
    windowBlurbehind: Symbol;

    /**
     *Method loads new document (replaces current one) in the current view from the given url. If now is equal to true this method loads document synchronously – method will return after document will be downloaded and loaded in the view.
     * @param {String} url
     * @param {bool} now
     * @returns {boolean}
     */
    load(url: String, now?: bool): boolean;

    /**
     *Method loads new document (replaces current one) in the current view from the given in-memory stream.
     * @param {Stream} stream
     * @returns {boolean}
     */
    load(stream: Stream): boolean;

    /**
     *
     Returns coordinates of the edges of the view. Parameters:

     part – one of symbolic constants #left, #top, #right, #bottom, #width or #height. Defines part of box (rectangle) to return. Additionally #part may accept the following constants:
     #rect – (x1,y1,x2,y2) metrics;
     #rectw – metrics as (x,y,width,height), default;
     #position – (x,y),
     #dimension – (width,height),
     edge, one of view:
     #border – border box edge – OS window border bounds,
     #client – client area edge,
     relativeTo, one of:
     #screen – returns coordinate relative to the origin of the screen,
     #self, default value – all coordinates are relative to the origin of the client area of the view.
     * @param part
     * @param edge
     * @param relativeTo
     * @returns {Integer}
     */
    box(part: Symbol, edge?: Symbol, relativeTo?: Symbol): Integer;

    /**
     *
     Returns screen(monitor) projection on cumulative desktop space. Parameters:

     area – one of symbolic constants #frame – monitor screen dimension, #workarea – monitor workarea (dimension modulo task/menu bars). In device pixels.
     part, one of view:
     #rect – (x1,y1,x2,y2) metrics, default;
     #rectw – metrics as (x,y,width,height);
     #position – (x,y),
     #dimension – (width,height),
     screenNo – integer, optional. If provided returns metrics of particular screen. If omitted returns metrics of this window screen.
     * @param {Integer} screenNo
     * @param area
     * @param part
     * @returns {Integer}
     */
    screenBox(screenNo?: Integer, area?: Symbol, part?: Symbol): Integer;

    /**
     *
     Replaces window of the view (dialog or frame) on the screen. This method is applicable only for standalone Sciter.

     If clientCoordinates is true x and y are interpretted as a desired position of the client area on the screen.
     * @param {Integer} x
     * @param {Integer} y
     * @param {boolean} clientCoordinates
     */
    move(x: Integer, y: Integer, clientCoordinates?: boolean): void;

    /**
     *
     Replaces window and changes dimension of the view (dialog or frame) on the screen. This method is applicable only for standalone Sciter.

     If clientCoordinates is true x,y, width and height are interpreted as a desired position/size of the client area on the screen.
     * @param {Integer} x
     * @param {Integer} y
     * @param {Integer} width
     * @param {Integer} height
     * @param {boolean} clientCoordinates
     */
    move(x: Integer, y: Integer, width: Integer, height: Integer, clientCoordinates?: boolean): void;

    /**
     *Returns or sets value of particular media variable.
     * @param {String} name
     * @param valueToSet
     * @returns {any | undefined}
     */
    mediaVar(name: String, valueToSet?: any): any | undefined;

    /**
     *
     If no newVars parameter provided then the method returns current set of media variables used by the view.

     If newVars is an object then the method will update view’s media variables from properties of the object. Returns undefined in this case.
     * @param {Object} newVars
     * @returns {Object | undefined}
     */
    mediaVars(newVars?: Object): Object | undefined;

    /**
     *Methods shows system file selector modal dialog and returns full path name of the selected file or null if user cancels this dialog.

     First parameter is either #save or #open symbol. If #save is provided then dialog will have a caption Save As… otherwise (#open) it will have caption Open…
     filter is a string – filter which defines list of allowed file extensions separated by character ‘|’ in the form: "label1|file.ext1|label2|file.ext1|.." where label is a label of item (appears in the selector on the dialog) and file.ext is a ‘;’ separated list of filename templates.
     ext is a string – default file extension used if user will type filename without extension.
     initialPath – string, if provided will open dialog with folder.
     dialogCaption – string, caption of the file open dialog.
     Following sample will popup dialog to select html files and will load file in current view:
     var fn = view.selectFile(#open,
     "HTML Files (*.htm,*.html)|*.HTM;*.HTML|All Files (*.*)|*.*" , "html" );
     if( fn ) view.load(fn);
     * @param {Symbol} action
     * @param {String} filter
     * @param {String} ext
     * @param {String} initialPath
     * @param {String} dialogCaption
     * @returns {String | String[] | null}
     */
    selectFile(action: Symbol, filter: String, ext: String, initialPath?: String, dialogCaption?: String): String | String[] | null;

    /**
     *Methods shows system folder selector modal dialog and returns full path name of the selected folder or null if user cancels this dialog.

     dialogCaption – string, caption of the file open dialog.
     defaultFolder – string, if provided shows dialog with that folder.
     Note that different platforms may have different UI for the selectFolder from the one used by view.selectFolder.
     * @param {String} dialogCaption
     * @param {String} defaultFolder
     * @returns {String | null}
     */
    selectFolder(dialogCaption?: String, defaultFolder?: String): String | null;

    /**
     *method of the dialog.
     Shows modal dialog defined by document at url or contained in in-memory stream. В object parameters if given will be copied to view.parameters variable available for scripts inside dialog HTML.

     alignment – integer, 1..9 – alignment of the window relative to the screen, -1 .. -9 – relative to its parent window, For meaning of the values see NUMPAD on the keyboard, e.g. alignment 5 means center/middle of the dialog will be placed in the center/middle of the screen.
     * @param {String | Stream} url
     * @param parameters
     * @param {Integer} alignment
     * @returns {any | undefined}
     */
    dialog(url: String | Stream, parameters?: any, alignment?: Integer): undefined | any;

    /**
     *
     Another form of calling modal dialog using single parameter object.

     The creationParams is an object that may have following fields:
     url – string, url of the document to load into the window;
     html – string, content to load into the window. Either url or html must be provided;
     x,y, width, height – integers, dimension of the window. If omitted dimensions will be calculated by intrinsic sizes of given document;
     client – true | false, if true then x,y, width, height above are treated as coordinates of client area rather than window box;
     parameters – object, parameters passed as they are to the view.parameters object of newly created window;
     caption – string, window caption;
     alignment – integer, 1..9 – alignment of the window relative to the screen, -1 .. -9 – relative to the parent.
     screen – integer, 0 .. View.screens – 1, if alignment is 1..9 then it determines screen/monitor where the window will appear, optional.
     If x,y and alignment provided then x,y defines reference point and the alignment defines relative position of the window against that point.
     * @param {Object} creationParams
     * @returns {any | undefined}
     */
    dialog(creationParams: Object): undefined | any;

    /**
     *symbol of the button pressed to close dialog.
     type – symbol, one of the following values: #alert, #information, #question or #warning ;
     text – string, either plain text or html ;
     title – string, caption of the dialog window;
     buttons – button definition(s), either:
     one of the symbols: #ok, #cancel, #abort, #ignore, #yes, #no or #close, or
     object with the structure { id:#somesymbol, text:"Some Text" } or
     array of symbols or objects above;
     onClose – function with the signature function(root, id) returning true|false. This function will be called on attempt to close dialog with parameters id – id of the button pressed and root – root node of the HTML document of the dialog. Function shall return true if dialog can be closed at the moment.
     onLoad – function with the signature function(root). This function will be called after creating dialog window. Use it if you need to do some initialization, e.g. fill data of input fields if text is an html containing <input>s.
     Samples:
     view.msgbox(#information, "I am fine!"); – will show simple message;
     view.msgbox(#question, "Be or not to be?", "Huh?",
     [ {id:#yes, text:"To be"}, {id:#no, text:"Not to be"} ] );
     * @param {Symbol} type
     * @param {String} text
     * @param {String} title
     * @param buttons
     * @param {(root: Node) => boolean} onLoad
     * @param {(root: Node, id: String) => boolean} onClose
     * @returns {Symbol | undefined}
     */
    msgbox(type: Symbol, text: String, title?: String, buttons?, onLoad?: (root: Node) => boolean, onClose?: (root: Node, id: String) => boolean): undefined | Symbol;

    /**
     *
     Creates separate window.

     The params is an object that may have following fields:
     type – int, window type, one of the following values: View.FRAME_WINDOW, View.TOOL_WINDOW and View.POPUP_WINDOW ;
     url – string, url of the document to load into the window;
     html – string, content to load into the window. Either url or html must be provided;
     x,y, width, height – integers, dimension of the window. If omitted dimensions will be calculated by intrinsic sizes of given document;
     client – true | false, if true then x,y, width, height above are treated as coordinates of client area rather than window box;
     state – integer. initial state of the window, either View.WINDOW_SHOWN, View.WINDOW_HIDDEN, View.WINDOW_MINIMIZED, View.WINDOW_MAXIMIZED or View.WINDOW_FULL_SCREEN;
     parameters – object, parameters passed as they are to the view.parameters object of newly created window;
     caption – string, window caption;
     alignment – integer, alignment of the window relative to the screen, -1 .. -9 – relative to the parent.
     screen – integer, 0 .. View.screens – 1, if alignment is 1..9 then it determines screen/monitor where the window will appear, optional.
     If x,y and alignment provided then x,y defines reference point and the alignment defines relative position of the window against that point.

     To open window in detached mode ( it will stay on screen even when its owner window is collapsed ) call the method as static one – using View class rather than view instance: View.window(...).
     * @param {Object} params
     * @returns {View}
     */
    window(params: Object): View;

    /**
     *closes current view (or dialog if it is view of dialog window). retval is any scripting object – return value of the dialog() function.
     * @param retval
     * @returns {undefined}
     */
    close(retval?: any): undefined;

    /**
     *
     Passes control to the operating system. Control is returned after the operating system has finished processing next event in its event queue. This method is used for implementing modal document loops.

     In case of:

     #wait – waits for the next event in the UI message queue, default behavior.
     #nowait – if there is any event in message queue handles it and returns immediately if there no any messages;
     #all – executes all pending messages in the message queue. Returns immediately if there no any messages;
     #untilMouseUp – "short circuiting", executes and dispatches messages until MOUSE_UP is received, used in drag scenarios;
     * @param {Symbol} action
     * @returns {undefined}
     */
    doEvent(action: Symbol): undefined;

    /**
     *Executes all pending changes in the view and renders what was changed on the screen. After this call box coordinates of all DOM elements are valid.

     Use this method when you need to commit all updates made on the DOM to the moment. For example:

     function retrieveDataFromDB(recordSet)
     {
       while(!recordSet.EOF())
       {
         grid.appendRow(recordSet.row);
         if(++numRowsAdded > 10)
         {
           numRowsAdded = 0;
           view.update();
         }
       }
     }
     * @returns {undefined}
     */
    update(): undefined;

    /**
     *
     Calls the callback function for each format of data presented in system clipboard at the moment. The callback function has following signature: function ( dataType: symbol ) {...}, where dataType is a symbol designating one of supported formats:

     #text
     – text/plain, represented bys string
     #html
     – text/html, represented by string;
     #picture
     – bitmap image, represented by object of type Image;
     #url
     – url or link, represented by object of the following structure: В { url: string , caption: string };
     #json
     – JSON data, represented as an object. returns integer – clipboard sequence number. Each change of clipboard buffer changes this number.
     * @param {(dataType: Symbol) => void} callback
     * @returns {undefined}
     */
    clipboard(callback: (dataType: Symbol) => void): undefined;

    /**
     *Fetches data from the clipboard in format defined by the dataType parameter. For list of allowed values see previous method definition.

     Note: for the #html format this function returns two values: source URL (if any) and html data per se.
     To get both of them use this : var (url, html) = view.clipboard(#get, #html);
     * @param {Symbol} action
     * @param {Symbol} dataType
     * @returns {String | Object | Image}
     */
    clipboard(action: Symbol, dataType: Symbol): String | Object | Image;

    /**
     *Stores data to the clipboard. When data is an object then it is expected that it has the following structure where all properties are optional except any one:

     {
        text: "some text",
        html: "<b>some html</b>",
        link: { caption: "some text", url: "file://some ..." },
        file: [ "path1",  "path2", ...],
        json: someData
     }
     Please note that json clipboard format is Sciter specific. You can use it to pass data between Sciter applications.

     You can set multiple data items at once (e.g. text and html together). Destination application will pick up format it understands in particular context.
     * @param {Symbol} action
     * @param {String | Object | Image} data
     * @returns {undefined}
     */
    clipboard(action: Symbol, data: String | Object | Image): undefined;;

    /**
     *The method returns next/previous/first/last focusable element in TAB order, either from element or from current element in focus.
     * @param {Symbol} which
     * @param {Element} from
     * @returns {Element}
     */
    focusable(which: Symbol, from?: Element): Element;

    /**
     *
     Performs system drag and drop operation.

     element is a DOM element that is used as a drag image, alternatively you can provide image and x/y icon offset as a drag image.

     data is an object that contain following properties:

     {text: String} – plain text string;
     {html: String | Element} – html, either as a string or outer HTML of given element;
     {file: String | [String, String, ...]} – single file name or list of file names to drop;
     {link: String | { caption: "some text", url: "file://some ..." }} – single url as a string or caption/url pair;
     {json: value} – any value that will be serialized into JSON string. JSON can be used to pass additional data between Sciter windows.
     The data object may contain multiple properties, destination will choose most appropriate.

     ddMode defines types of drag-n-drop operations allowed:

     #copy – copy from source to destination;
     #move – move from source to destination;
     #any – either move or copy.
     performDrag() is a blocking operation – the function returns when drag-n-drop is complete or rejected.
     * @param {Element | Image} element
     * @param {Integer} xOffset
     * @param {Integer} yOffset
     * @param {Object} data
     * @param {Symbol} ddMode
     * @returns {Symbol | null}
     */
    performDrag(element: Element | Image, xOffset: Integer, yOffset: Integer, data: Object, ddMode: Symbol): null | Symbol;

    /**
     *Returns cursor location relative to client area of the view:
     var (x,y) = view.cursorLocation();

     on
     ( nameandns: string, handler: function ) : view
     Attaches the handler to one of view (window) related events.

     nameandns – string that contains one of the event names at the bottom and optionally arbitrary namespace name in the form "name.namespace".

     off
     ( eventname: string | handler: function ) : view
     Detaches event handler either by name or by function itself.

     eventname here is either "name", full "name.namepsace" or just ".namepsace". Example:

     view.off(".mymodule");
     will unsubscribe both event handlers set by the code:

     view.on("move.mymodule",foo)
     .on("size.mymodule",foo);
     * @returns {MultipleReturnValue}
     */
    cursorLocation(): MultipleReturnValue //(x:Integer, y: Integer);

    /**
     * Attaches the handler to one of view (window) related events.

     nameandns – string that contains one of the event names at the bottom and optionally arbitrary namespace name in the form "name.namespace".
     "size"
     Event is generated after dimensions of the view (window) was changed. Use view.box() method to get dimensions.
     "sizing"
     Event is generated while user is changing dimensions of resizable window. Function-handler shall have signature: function(sizingParams) where sizingParams is an object of this structure: { x:integer, y:integer, width:integer, height: integer, side: 1...9 } – proposed dimensions of the window and side is a window side/corner dragged to change window dimension.
     "move"
     Event is generated after position of the view (window) was changed. Use view.box() method to get dimensions and positions.
     "moving"
     Event is generated while user is moving the window by dragging it by caption. Function-handler shall have signature: function(movingParams) where movingParams is an object of this structure: { x:integer, y:integer, width:integer, height: integer } – proposed dimensions of the window. Function-handler can change properties of the object discriminating window movements.
     "statechange"
     Event is generated when state of the view (maximized, minimized, hidden, shown ) was changed. See View.state property.
     "resolutionchange"
     Event is generated when window PPI (pixels per inch scale factor) changes. To get actual pixels-per-inch value use:
     var ppi = (1in).toFloat(#px); and to get pixels-per-dip:
     var ppdip = (1dip).toFloat(#px);
     "mediachange"
     Event is generated when one of media variables changes (including resolution change), for example when number of monitors or color depth changes.
     "replacement-start"
     Event is generated when user starts replacing (moving and/or sizing) of the window by UI means (e.g. dragging it by caption).
     "replacement-end"
     Event is generated after user completes the window replacement by UI means (e.g. dragging it by caption).
     "activate"
     The event is generated when Sciter window gets activated or deactivated. Event handling function may have parameter mode defined that will take one of the following values:
     false – window is deactivated;
     true – window is activated somehow but not by mouse;
     #by-mouse – window is activated by mouse click on it.
     "closing"
     The event is generated as a part of view(window) closing sequence, delivered before view’s document gets destroyed.
     "close"
     Very last event from view (window), delivered immediately before view (window) is destroyed
     * @param {String} nameandns
     * @param {() => boolean} handler
     * @returns {View}
     */
    on(nameandns: String, handler: () => boolean): View;

    /**
     *
     Detaches event handler either by name or by function itself.

     eventname here is either "name", full "name.namepsace" or just ".namepsace". Example:

     view.off(".mymodule");
     will unsubscribe both event handlers set by the code:

     view.on("move.mymodule",foo)
     .on("size.mymodule",foo);
     * @param {() => (boolean | String)} eventname
     * @returns {View}
     */
    off(eventname: () => boolean | String): View;

    /**
     *
     Sends HTTP request with params object having following fields:

     type – symbol, HTTP verb, one of : #get, #post, #put or #delete, default: #get ;
     url – string, url;
     protocol – symbol,  one of #basic, #multipart and #json  ;
     params – object, HTTP request parameters;
     headers – object, additional HTTP request headers;
     success – function(data,status), callback function to be called on successful completion.
     error – function(err,status), callback function to be called on request failure.
     complete – function(data or err,status), callback function to be called on request completion (either success or error).
     progress – function(bytesReceived, totalBytes), callback function to be called on each chunk of data received. bytesReceived is an integer – number of bytes received so far and totalBytes is an integer – total bytes as reported by server in HTTP’s "content-length" field. totalBytes can be undefined if server does not report it.
     toFile – string, if provided shall contain path of the file where to store the response. Used in file download scenarios.
     proxyHost, proxyPort – string, integer. If these two are provided then the request will go through that proxy host.
     output – symbol, one of #string | #stream | #bytes | #json. If provided forces data to be reported as instance of String, Stream, Bytes or a value – result of JSON parsing.
     noCache – true | false, if true then request will not use reading from cache nor writing the request response to cache.
     Sample: sdk/samples/communication/file-download.htm and sdk/samples/communication/http.tis
     * @param {Object} params
     * @returns {undefined}
     */
    request(params: Object): undefined;
}

interface Duration {

}

interface Image {

}